// Copyright (c) 2009, Regents of the Rothstein Lab of Columbia University// All rights reserved.// // Redistribution and use in source and binary forms, with or without modification, are permitted for non-commercial use provided that the following conditions are met:// //     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.//     * Neither the name of Columbia University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.// ignore LARGE STRAIGHT PARTICLES AT BORDERS// SELECT ALL PARTICLES WITHIN SELECTION????// 		Find edge, expand rectangle, use magic wand on all centroids// add function to prevent user from overwrting there images. For instance if they have a scan called:// cln1,1,2,1,3 the file cln1,1.tif will get written twice...maybe?// errorLog messages are currently not printed until all images of a particular step (ie rough cropping, // fine cropping, or measurment) have been processed. If there are errors and the program crashes the// the corresponding errorLog messages will be lost// new, more computationally efficient way to calculate standard deviation://for (i=0; i<n; i++) {//          value = profile[i];//          sum += value;//          sum2 += value*value;//     }//      mean = sum/n;//      stdDev = (n*sum2-sum*sum)/n;//      stdDev = sqrt(stdDev/(n-1.0));//      print("mean="+mean + ", stddev=" + stdDev);macro 'ScreenMill - CM Engine [c]'{	requires("1.45"); 	cmVersion = 1.54;	showStatus("Checking for newer version of CM Engine...");	rothsteinWebsiteVersion=File.openUrlAsString("http://www.rothsteinlab.com/tools/cm_engine/version.txt");	showStatus("");	if(parseFloat(rothsteinWebsiteVersion) > cmVersion){		Dialog.create("A New Version of CM Engine Is Available!");		Dialog.addMessage("A newer version of CM Engine is available on the Rothstein Lab website. Please goto 'http://www.rothsteinlab.com/tools/screen_mill/cm_engine' to download it.");//" or click the 'help' button to open this URL in your web browser.") 		//Dialog.addHelp("http://www.rothsteinlab.com/tools/screen_mill/cm_engine");		Dialog.show();	}		// ********************************************************	// ********************************************************	// IMPORTANT VARIABLES THAT YOU MAY WISH TO MODIFY!!!!		// ********************************************************	// ********************************************************		// for rough crops, meaning cropping scans of multiple plates into individual plate images	lowWidth=3.25; // low width is the minimal width of scan, default value is approximately the width of one plate (3.25 inches)	highWidth=16.1; // highWidth is the maximal width of scan, default value is approximately the width the Rothstein lab scanner (16.1 inches)	singlePlateLowWidth=2.8; // singlePlateLowWidth = low width range (floor) of a single plate. Default = 2.8 inches	singlePlateHighWidth=3.6; // singlePlateHighWidth = high width range (ceiling) of a single plate. Default = 3.6 inches	singlePlateLowHeight=4.3; // singlePlateLowHeight = low height range (floor) of a single plate. Default = 4.3 inches	singlePlateHighHeight=5.3; // singlePlateHighHeight = high height range (ceiling) of a single plate. Default = 5.3 inches		// others	alpha=newArray('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','AA','AB','AC','AD','AE','AF','AG','AH','AI','AJ','AK','AL','AM','AN','AO','AP','AQ','AR','AS','AT','AU','AV','AW','AX','AY','AZ','BA','BB','BC','BD','BE','BF','BG','BH','BI','BJ','BK','BL','BM','BN','BO','BP','BQ','BR','BS','BT','BU','BV','BW','BX','BY','BZ','CA','CB','CC','CD','CE','CF','CG','CH','CI','CJ','CK','CL','CM','CN','CO','CP','CQ','CR','CS','CT','CU','CV','CW'); // alphabet array, not really used heavily in this iteration of the macro, but will be in the future.	illegalLogFileNameChars=newArray("[","]","/","\\","?","<",">",":","\"","|",".",""); // character that are banned from being included in the log file name the user can enter	sizeCutoff = 10; // when finding plate borders, sizeCutoff is the threshold below which particles will be ignored	validationThreshold = 15; // threshold value for checkPlate function. Higher values == less stringent checking	growthCutOff = 25; // size cutoff of a colony that is considered to be growing. Used in the measure standard function	deadCutoff = 0.4; // once the average of growing colonies is determined any colony below deadCutoff*growthAverage will be considered dead. Used in measure standard function	circLimit=0.7; // in measure standard function any particle with circularity greater then this should be okay, anything with a circularity < this will be subject to some scrutiny	// ********************************************************	// ********************************************************	// END IMPORTANT VARIABLES THAT YOU MAY WISH TO MODIFY!!!!		// ********************************************************	// ********************************************************		// set parameters to measure when running 'analyze particles'	run("Set Measurements...", "area mean min centroid bounding circularity redirect=None decimal=6"); 	home_dir = getDirectory("Choose Parent Directory."); // get source directory	files= getFileList(home_dir); // get file listing (array)	// ---------------------------------------------------------	// BEGIN IDENTIFYING CONDITIONS IN FILE NAMES!!!!!!!!!!	// ---------------------------------------------------------	// look for sub-condition identifiers in scans. Scans may contain several plates.	// filenames should be structured as: query,plateNumber1condition,plateNumber2condition,,plateNumber_n_condition...	// conditions are added via special characters, see below	condition_ids=identifyconditions(files, home_dir);	// ---------------------------------------------------------	// END IDENTIFYING cONDITIONS IN FILE NAMES!!!!!!!!!!	// ---------------------------------------------------------	// ------------------------------------	// BEGIN DIALOG SETUP HERE !!!!!!!!!!	// ------------------------------------	// have to define condition_labels prior to entering dialogSetup because you cannot	// return an array of arrays. Defining before we enter to function will allow it to be modified in the	// function without having to return it. Any changes made to condition_labels within the function will	// remain when we return from the function 	results=dialogSetup(condition_ids);	mode=results[0];	density=results[1];	logFileName=results[2];	rows=results[3];	cols=results[4];	condition_labels=split(results[5],"\t");	showDebug=results[6];	cropMode=results[7];	if(!showDebug){setBatchMode(true);} // run up to 6 times faster by not showing images on screen	// ------------------------------------	// END DIALOG SETUP HERE !!!!!!!!!!	// ------------------------------------	// ------------------------------------	// START ROUGH CROPPING HERE !!!!!!!!!!	// ------------------------------------	// rough crops scans in home_dir	processScans(home_dir, files, condition_ids, condition_labels);	// ------------------------------------	// END ROUGH CROPPING!!!!!!!!!!	// ------------------------------------	if(showDebug){showMessageWithCancel("Rough crop complete. Begin auto-alignment.");}		// important variables up to this point required for the rest of the program to work properly	// cols, density, dir1, logFileName, mode, rows, home_dir		// ------------------------------------	// BEGIN FINE CROPPING HERE!!!!!!!!!!	// ------------------------------------	// fine crops images in the "rough_crops" directory	alignANDfineCropImages(home_dir, density, rows, cols,cropMode);	// ------------------------------------	// END FINE CROPPING HERE!!!!!!!!!!	// ------------------------------------		// ------------------------------------	// BEGIN MEASURING COLONIES HERE!!!!!	// ------------------------------------	// quantitate images in the "fine_crops" directory	measureColonies(home_dir, rows, cols, density, mode, logFileName);	// DONE!!!}// function : alignANDfineCropImages// inputs:// home_dir -> parent image processing directory// density -> number of colonies on a plate// rows and cols -> number of rows and columns that make up the grid of colonies// cropMode --> automated mode or manual mode// purpose:// This function will analyze crops in the rough_crop directory, straighten them out (align) and then fine crop them// (crop image so that borders are close to edge of colonies). Once images are fine crops the grid// layout is verified using the checkPlate function. Upon verification plates are move into the fine_crops directory.// if an image fails validation, or at any other step in this funciton, it is moved into the fine_crop_errors folderfunction alignANDfineCropImages(home_dir, density, rows, cols,cropMode){	run("Clear Results"); // uuummm this clears the results dialog	print("\\Clear"); // clear log file	errorLog="";	// assume we are either in the directory where the "rough crops" are (the "rough_crops/" directory) or its parent directory	current_dir='';	if(File.isDirectory(home_dir+"rough_crops/")){current_dir=home_dir+"rough_crops/";}	files= getFileList(current_dir); // store list of current files in "files" array	createProgressBar("Fine Crop Progress");	run("Set Scale...", "unit=");	run("Set Measurements...", "area mean min centroid bounding circularity integrated median redirect=None decimal=6");	thresholdImages=true;	batchMode=true;	if(cropMode == "Manual"){setBatchMode(false);thresholdImages=false;batchMode=false;}		success_dir=home_dir+"fine_crops/";	error_dir=home_dir+"fine_crop_errors/";		for (xx=0; xx<files.length; xx++){		collect_garbage(50); // free up some memory		file=split(files[xx],"."); // split file name base on periods		lastIndex=file.length-1; // get last index of array we just created		extension=file[lastIndex]; // file[lastIndex] should be == to the file extension		errorReport = "false"; // errorReport having a false value is a good thing		cur_path=current_dir+files[xx];				if(File.isDirectory(cur_path)!=1 && (extension=="tiff" || extension=="tif" || extension=="gif" || extension=="jpeg" || extension=="bmp" || extension=="jpg" || extension=="png")){			//if(showDebug){showMessageWithCancel(dir1+files[xx]+"\n"+extension);}			onOpenMethods(cur_path,0, "yes",density, '', thresholdImages); // prepare image for processing			collect_garbage(50);	 // free up some memory			if(cropMode != "Manual"){				width = getWidth();				height = getHeight();					if(thresholdImages){					thresholdIssueSize = width*height*0.2;					analyzeParticles(thresholdIssueSize,0.00,'');					if(nResults > 0){						// THRESHOLD ISSUE IN THIS PLATE!!!						showMessageWithCancel("The image "+files[xx]+" could not be analyzed by the method you chose because a threshold filter could not be successfully applied to it. If this occurs with several of your images you should use 'Background Subtracted' mode instead.");						errorReport="true";						moveImage(current_dir, error_dir, files[xx], 0, 0, width, height, 0, "true"); // move image to error directory						errorLog=errorLog+"Could not apply a threshold filter to plate: "+files[xx]+", image not cropped.\n\n";					}				}				// particles are already analyzed in onOpenMethods but with a minimum size of 20, redo it with a smaller minimum size				// not sure why this was here				// analyzeParticles(5,0.00,""); 										// ------------------------------------				// BEGIN PLATE ROTATION!!!				// ------------------------------------				// assumptions about plate rotation...				// colonies lie in an ordered grid				// colonies are composed of a single particle				if(errorReport == "false"){					run("Clear Results");						// pos variables define where to draw the selection boxes					pos1=width*0.1; pos2=width*0.45; pos3=width*0.8; // left, middle, right					x=newArray( pos1,pos2,pos3,pos1,pos2,pos3,pos1,pos2,pos3); // x positions						pos1=height*0.15; pos2=height*0.45; pos3=height*0.75; // top, middle, bottom					y=newArray( pos1,pos1,pos1,pos2,pos2,pos2,pos3,pos3,pos3 ); // y positions										// set the dimensions of the selection boxes we will be drawing					if(density == 1536 || density == 2304){						recWidth=x[0];						recHeight=x[0];					}					else if(density == 384){						recWidth=width*0.15;						recHeight=recWidth;					}					else if(density == 96){						recWidth=width*0.30;						recHeight=recWidth;					}										cum_angle=0; // store the sum of the averages calculated					// correction_count=number of times we have successfully found a 3 x 3 area and calculated angles to rotate from it					correction_count=0;					for(pos=0;pos<x.length;pos++){						errorReport="false"; // initialize errorReport to indicate that we are not having any problems												// if the selection box we are about to draw does not lie within the borders of the image						// then move it						if( (x[pos]+recWidth) > width ){x[pos] = x[pos]+recWidth - width - 1;} 						if( (y[pos]+recHeight) > height ){y[pos] = y[pos]+recHeight - height - 1;}												// draw rectangle						makeRectangle(x[pos], y[pos], recWidth, recHeight);						if(showDebug){showMessageWithCancel("pos = "+pos);}						// exact center of square selection						centerX=x[pos]+(recWidth/2);						centerY=y[pos]+(recHeight/2);							// have a circularity constraint to avoid analyzing shmutz on the plate						// analyze particles, only consider those > 5 in size and with a circularity >= 0.8						// exclude particles that overlap border of rectangular selection, clear results window before analysis						run("Analyze Particles...", "size=5-Infinity circularity=0.80-1.00 show=Nothing exclude clear");						x_array=newArray(nResults); // will store x centroid coordinates						y_array=newArray(nResults); // will store y centroid coordinates												// smallest_eDistance will store the smallest distance between the center of the selection 						// box and the centroids of the particles within the selection box. Arbitrarily initialize 						// it to a very large value						smallest_eDistance=width; 							// cX and cY will be the centroid coordinates of closest colony to exact center of square selection						// this particle should correlate to the center to the 3x3 grid of particles we will be 						// analyzing...						cX=0; cY=0;							// maxColDiameter will hold the maximum width of a colony that we come across						maxColDiameter=0;						// colonyWidth will store the width of the current particle we are analyzing						colonyWidth=0;						//if(showDebug){showMessageWithCancel(nResults);}						// find colony closest to center of selection box						for(ii=0;ii<nResults;ii++){							// X and Y centroid values of colony							centroid_x=getResult("X",ii);							centroid_y=getResult("Y",ii);							distance=eDistance(centerX,centerY,centroid_x,centroid_y);							if(distance < smallest_eDistance){								cX=centroid_x;								cY=centroid_y;								smallest_eDistance=distance;							}							x_array[ii]=centroid_x;							y_array[ii]=centroid_y;							colonyWidth=getResult("Width",ii);							if(colonyWidth > maxColDiameter){maxColDiameter=colonyWidth;}						}												// x_closest and y_closest will store the centroid coordinates of the 8 closest particles 						// the particle at cX, cY						x_closest=newArray(8);						y_closest=newArray(8);						// closest_distances will store the 8 distances closest to the particle at cX and cY 						closest_distances=newArray(width,width,width,width,width,width,width,width);							// centroid closest to center is at cX,cY...find closest 8 centroid values to it						for(ii=0;ii<x_array.length;ii++){										if(x_array[ii]!=cX && y_array[ii]!=cY){									distance=eDistance(cX,cY,x_array[ii],y_array[ii]);								for(j=0;j<8;j++){									if(distance < closest_distances[j]){										for(k=7;k>j;k--){											closest_distances[k]=closest_distances[k-1];											x_closest[k]=x_closest[k-1];											y_closest[k]=y_closest[k-1];										}										closest_distances[j]=distance;										x_closest[j]=x_array[ii];										y_closest[j]=y_array[ii];										j=10; // break out of loop									}								}							}						}							//if(showDebug){showMessageWithCancel("Closest Distance = "+closest_distances[0]+"\nMax Col Diameter - "+maxColDiameter);}						// if the closest distance is < the maximum particle diameter within the selection box						// we are analyzing then we have a problem						if(closest_distances[0]<maxColDiameter){errorReport="true";}												// now that we have the 9 particles that lie within a 3 x 3 grid of particles we need to 						// analyze them to determine where they lie within the grid						if(errorReport=="false"){							minE=closest_distances[0]*0.9;								// horizontal linear							leftLinearX=0; leftLinearY=0;							rightLinearX=0; rightLinearY=0;								// vertical linear							topLinearX=0; topLinearY=0;							bottomLinearX=0; bottomLinearY=0;								// top left to bottom right diagonal							topLeftDiagX=0; topLeftDiagY=0;							bottomRightDiagX=0; bottomRightDiagY=0;								// bottom left to top right diagonal							bottomLeftDiagX=0; bottomLeftDiagY=0;							topRightDiagX=0; topRightDiagY=0;								yCeiling = cY+minE;							yFloor=cY-minE;								xCeiling = cX+minE;							xFloor=cX-minE;								// have now found 8 closest centroid values...							// now need to verify that 4 corner distances and 4 non corner distances are close to one another...							// allow 10% difference between min and max...							max=0;							min=width;							//if(showDebug){showMessageWithCancel("ok so far");}							// first look at closest 4 which correspond to the linear lines							for(ii=0;ii<4;ii++){								// left linear								if(x_closest[ii] < cX && y_closest[ii] < yCeiling && y_closest[ii] > yFloor){									//if(showDebug){showMessageWithCancel(x_closest[ii]+", "+y_closest[ii]);}									leftLinearX=x_closest[ii];									leftLinearY=y_closest[ii];								}								// right linear								if(x_closest[ii] > cX && y_closest[ii] < yCeiling && y_closest[ii] > yFloor){									rightLinearX=x_closest[ii];									rightLinearY=y_closest[ii];								}								// top linear								if(y_closest[ii] < cY && x_closest[ii] < xCeiling && x_closest[ii] > xFloor){									topLinearX=x_closest[ii];									topLinearY=y_closest[ii];								}								// bottom linear								if(y_closest[ii] > cY && x_closest[ii] < xCeiling && x_closest[ii] > xFloor){									bottomLinearX=x_closest[ii];									bottomLinearY=y_closest[ii];								}								if(closest_distances[ii]<min){min=closest_distances[ii];}								if(closest_distances[ii]>max){max=closest_distances[ii];}							}							if( ((min/max) < 0.85) || leftLinearX == 0 || leftLinearY == 0 || rightLinearX == 0 || rightLinearY == 0 || topLinearX == 0 || topLinearY == 0 || bottomLinearX == 0 || bottomLinearY == 0){errorReport="true";}							//if(showDebug){showMessageWithCancel("Error Report = "+errorReport+"\nMin / Max ratio = "+(min/max)+"\nleftLinearX = "+leftLinearX+"\nleftLinearY = "+leftLinearY+"\nrightLinearX = "+rightLinearX+"\nrightLinearY = "+rightLinearY+"\ntopLinearX = "+topLinearX+"\ntopLinearY = "+topLinearY+"\nbottomLinearX = "+bottomLinearX+"\nbottomLinearY = "+bottomLinearY);}														if(errorReport=="false"){								// next look at last 4 which correspond to the diagonal lines								max=0;								min=width;								for(ii=4;ii < 8;ii++){									// top-left diag									if(x_closest[ii] < cX && y_closest[ii] < cY){										topLeftDiagX=x_closest[ii];										topLeftDiagY=y_closest[ii];									}									// bottom-right diag									if(x_closest[ii] > cX && y_closest[ii] > cY){										bottomRightDiagX=x_closest[ii];										bottomRightDiagY=y_closest[ii];									}									// bottom-left diag									if(x_closest[ii] < cX && y_closest[ii] > cY){										bottomLeftDiagX=x_closest[ii];										bottomLeftDiagY=y_closest[ii];									}									// top-right diag									if(x_closest[ii] > cX && y_closest[ii] < cY){										topRightDiagX=x_closest[ii];										topRightDiagY=y_closest[ii];									}									if(closest_distances[ii]<min){min=closest_distances[ii];}									if(closest_distances[ii]>max){max=closest_distances[ii];}								}								if( ((min/max) < 0.90) || topLeftDiagX == 0 || topLeftDiagY == 0 || bottomRightDiagX == 0 || bottomRightDiagY == 0 || bottomLeftDiagX == 0 || bottomLeftDiagY == 0 || topRightDiagX == 0 || topRightDiagY == 0){errorReport="true";}								//if(showDebug){showMessageWithCancel("Error Report = "+errorReport+"\nMin / Max ratio = "+(min/max)+"\ntopLeftDiagX = "+topLeftDiagX+"\ntopLeftDiagY = "+topLeftDiagY+"\nbottomRightDiagX = "+bottomRightDiagX+"\nbottomRightDiagY = "+bottomRightDiagY+"\nbottomLeftDiagX = "+bottomLeftDiagX+"\nbottomLeftDiagY = "+bottomLeftDiagY+"\ntopRightDiagX = "+topRightDiagX+"\ntopRightDiagY = "+topRightDiagY);}																if(errorReport=="false"){									// if we are here then everything is copacetic....										// we now have x and y coordinates for the center of the corner colonies within our 3x3 selection									// Use trigonometry to determine the angle that the plate should be rotated to allow the horizontal and vertical									// colonies to line in a straight line and for the diagonals to line at a 45 degree angle										horizontal_x_diff=rightLinearX-leftLinearX; 									horizontal_y_diff=leftLinearY-rightLinearY; 									horizontal_angle=atan( (horizontal_y_diff/horizontal_x_diff) )*(180/PI);										vertical_y_diff=bottomLinearY-topLinearY; 									vertical_x_diff=bottomLinearX-topLinearX; 									vertical_angle=atan((vertical_x_diff/vertical_y_diff))*(180/PI);										first_diag_x_diff=bottomRightDiagX-topLeftDiagX;									first_diag_y_diff=bottomRightDiagY-topLeftDiagY;									first_diag_angle=atan((first_diag_x_diff/first_diag_y_diff))*(180/PI);										second_diag_x_diff=topRightDiagX-bottomLeftDiagX;									second_diag_y_diff=bottomLeftDiagY-topRightDiagY;									second_diag_angle=atan((second_diag_x_diff/second_diag_y_diff))*(180/PI);										ave_angle=(horizontal_angle+vertical_angle+(first_diag_angle-45)+(45-second_diag_angle))/4;									cum_angle+=ave_angle;										//if(showDebug){showMessageWithCancel("h = "+horizontal_angle+"\nv = "+vertical_angle+"\n1st = "+(first_diag_angle-45)+"\n2nd = "+(45-second_diag_angle)+"\nave_angle = "+ave_angle);}									correction_count++;								}								//else{if(showDebug){showMessageWithCancel("no go");}}							}						}						errorReport="false";					}					errorReport="false";					angle=0;					if(correction_count>0){						run("Select All"); angle=(cum_angle/correction_count);						onOpenMethods(cur_path, angle,"",density, '',true);					}					else{ errorReport="true";angle=0;}					if(errorReport == "true"){//errorLog=errorLog+"Plate: "+files[xx]+" was not rotated at all. If this plate fails after this point the error in rotation may be to blame.\n";					}					errorReport="false";				}					collect_garbage(50);				if(showDebug){showMessageWithCancel("Rotated\nAngle = "+angle+"\nerrorLog = "+errorLog+"\n"+files[xx]);}				// ------------------------------------				// END PLATE ROTATION!!!				// ------------------------------------				if(showDebug){showMessageWithCancel("Auto-alignment complete. Begin fine cropping.");}				// ------------------------------------				// BEGIN LOOKING FOR BORDERS AND FINE CROP				// ------------------------------------				if(errorReport == "false"){					// APPROACH.....					// draw selection box in center of plate, analyze particles and only consider those					// >25 in size (death cutoff) and with a circularity of 0.5 or >, exclude particles					// close to edge of selection box.					// figure out average colony width and height.					// figure out average distance between colony borders (average of (BX+colony width)-BX of colony to the right of it...same for Y)					// figure out centroid locations for top and bottom rows of colonies within selection, as well as centroid locations					// of left and right columns...					// now have width, and distance between colonies					// draw rectangular selection whose width = average colony width (or height) + average distance between borders					// position selection over center of centroid values calculated above...					// analyze particles within selection, get average circularity and number of particles (= base_cir and base_num_par, respectively)					// move selection box toward borders, jumping the width (or height) of the selection box, again analyze particles					// check if analyze of particle variables does not significantly differ from base calculations, if it does we have gone one step to far					// tentative border = border of selection box closest to plate interior.  Check border by moving towards center of plate till you 					// hit black....						// pos variables define where to draw the initial selection rectangle					startX=width*0.12;					xWidth=width*0.78;					startY=height*0.15;					yHeight=height*0.68;					makeRectangle(startX, startY, xWidth, yHeight);					if(showDebug){showMessageWithCancel("i made a rectangular selection!");}					// determine average colony value, store centroid values, find max and min centroid values,					// determine average colony width and height					minX=width;					maxX=0;					minY=height;					maxY=0;					colonyWidth=0;					colonyHeight=0;					run("Analyze Particles...", "size="+sizeCutoff+"-Infinity circularity=0.80-1.00 show=Nothing exclude clear");						// this if statement is required but the cutoff is arbitrary					if(nResults > 10){						totalParticles=nResults;						x_centroids=newArray(totalParticles);						y_centroids=newArray(totalParticles);						value=0;						for (i=0; i<totalParticles; i++){							value = value+getResult("Mean",i);							// store X and Y centroid values of colony							x_centroids[i]=getResult("X",i);							y_centroids[i]=getResult("Y",i);							// determine if the centroid values are min or max							if(x_centroids[i]>maxX){maxX=x_centroids[i];}							if(x_centroids[i]<minX){minX=x_centroids[i];}							if(y_centroids[i]>maxY){maxY=y_centroids[i];}							if(y_centroids[i]<minY){minY=y_centroids[i];}							// store width and height of particle							colonyWidth+=getResult("Width",i);							colonyHeight+=getResult("Height",i);						}						if(showDebug){showMessageWithCancel("value = "+value+"\nnResults = "+nResults);}						if(value>0){value=value/nResults;}						colValue = value;						aveHeight=colonyWidth/totalParticles; // average height of colony in rectangle						aveWidth=colonyHeight/totalParticles; // average width of colony in rectangle						halfHeight=aveHeight/2;						halfWidth=aveWidth/2;						//selectWindow("Results");										// aveWhite will = average distance between colony edges...						aveWhiteX=0;						aveWhiteY=0;							// iterate over array of centroid positions, try to group centroid values into 						// the row which they belong in.						// We know the max x centroid position, this is our reference.  We can look for other x-centroid values 						// within a specific range of the reference.  The range is defined by aveWidth.  All centroids 						// that have a x-centroid coordinate within range of the reference should be on the same line.  Within this group						// of x-positions we look for the max and min y values, these correlate to the right most top and bottom						// colonies within the rectangular selections.						// A similar situation exists for the min x centroid position						// once finished we will have the x and y coordinates for the colonies at the corners of our rectangular selection						minX+=aveWidth;						maxX-=aveWidth;						minY+=aveWidth;						maxY-=aveWidth;						leftRangeCeiling=minX+aveWidth;						leftRangeFloor=minX-aveWidth;						rightRangeCeiling=maxX+aveWidth;						rightRangeFloor=maxX-aveWidth;						topRangeCeiling=minY+aveHeight;						topRangeFloor=minY-aveHeight;						bottomRangeCeiling=maxY+aveHeight;						bottomRangeFloor=maxY-aveHeight;						// define length of array as the dimensions of the plate, this is slightly to0 large, but whatever						leftCentroids=newArray( rows*2 );						rightCentroids=newArray( rows*2);						topCentroids=newArray( cols*2 );						bottomCentroids=newArray( cols*2 );						// counters keep track of how many items we have added to the arrays initialized above						lcount=0; rcount=0; tcount=0; bcount=0;						aveLeftCentroidX=0;						aveRightCentroidX=0;						aveTopCentroidY=0;						aveBottomCentroidY=0;							// THIS ENTIRE SECTION TO FIND THE AVERAGE DISTANCE BETWEEN LEFT RIGHT TOP AND BOTTOM COLONIES SEEMS EXTREMELY INEFFICIENT AND SHOULD PROBABLY						// BE IMPLIMENTED IN SOME OTHER MANNER						collect_garbage(50);						//if(showDebug){showMessageWithCancel("rightRangeCeiling = "+rightRangeCeiling+"\nrightRangeFloor = "+rightRangeFloor+"\nhalfWidth = "+halfWidth+"\nx_centroids[ii] = "+x_centroids[ii]+"\ny_centroids[ii] = "+y_centroids[ii]);}						for(ii=0;ii<x_centroids.length;ii++){							// if x-centroid value falls within range, consider it....							if(x_centroids[ii] < leftRangeCeiling && x_centroids[ii] > leftRangeFloor){								// if this is the 1st centroid readjust the range values so that we only consider particles within the same row (or col)								if(lcount==0){leftRangeFloor=x_centroids[ii]-halfWidth;leftRangeCeiling=x_centroids[ii]+halfWidth;}								leftCentroids[lcount++]=ii; 								aveLeftCentroidX+=x_centroids[ii];							}							if(x_centroids[ii] < rightRangeCeiling && x_centroids[ii] > rightRangeFloor){								if(rcount==0){rightRangeFloor=x_centroids[ii]-halfWidth;rightRangeCeiling=x_centroids[ii]+halfWidth;}								rightCentroids[rcount++]=ii;								aveRightCentroidX+=x_centroids[ii];							}							// if y-centroid value falls within range, consider it....							if(y_centroids[ii] < bottomRangeCeiling && y_centroids[ii] > bottomRangeFloor){								if(bcount==0){bottomRangeFloor=y_centroids[ii]-halfHeight;bottomRangeCeiling=y_centroids[ii]+halfHeight;}								bottomCentroids[bcount++]=ii;								aveBottomCentroidY+=y_centroids[ii];							}							if(y_centroids[ii] < topRangeCeiling && y_centroids[ii] > topRangeFloor){								if(tcount==0){topRangeFloor=y_centroids[ii]-halfHeight;topRangeCeiling=y_centroids[ii]+halfHeight;}								topCentroids[tcount++]=ii;								aveTopCentroidY+=y_centroids[ii];							}						}						minCount = 5;						// if any of the counts are < minCount move bounds in one row/col and try again (try up to row or cols times)						while(lcount < minCount && errorReport !="true"){							lcount=0; aveLeftCentroidX=0;							leftRangeFloor=leftRangeCeiling;leftRangeCeiling=leftRangeCeiling+aveWidth*2;							for(ii=0;ii<x_centroids.length;ii++){								// if x-centroid value falls within range, consider it....								if(x_centroids[ii] < leftRangeCeiling && x_centroids[ii] > leftRangeFloor){									// if this is the 1st centroid readjust the range values so that we only consider particles within the same row (or col)									if(lcount==0){leftRangeFloor=x_centroids[ii]-halfWidth;leftRangeCeiling=x_centroids[ii]+halfWidth;}									leftCentroids[lcount++]=ii; 									aveLeftCentroidX+=x_centroids[ii];								}							}							if(leftRangeCeiling>rightRangeFloor){errorReport="true";}						}						collect_garbage(50);						while(rcount < minCount && errorReport !="true"){							rcount=0; aveRightCentroidX=0;							rightRangeCeiling=rightRangeFloor; rightRangeFloor=rightRangeFloor-aveWidth*2;							for(ii=0;ii<x_centroids.length;ii++){								if(x_centroids[ii] < rightRangeCeiling && x_centroids[ii] > rightRangeFloor){									if(rcount==0){rightRangeFloor=x_centroids[ii]-halfWidth;rightRangeCeiling=x_centroids[ii]+halfWidth;}									rightCentroids[rcount++]=ii;									aveRightCentroidX+=x_centroids[ii];								}							}							if(rightRangeFloor<leftRangeCeiling){errorReport="true";}						}						while(bcount < minCount && errorReport !="true"){							bcount=0; aveBottomCentroidY=0;							bottomRangeCeiling=bottomRangeFloor; bottomRangeFloor=bottomRangeFloor-aveHeight*2;							for(ii=0;ii<x_centroids.length;ii++){								if(y_centroids[ii] < bottomRangeCeiling && y_centroids[ii] > bottomRangeFloor){									if(bcount==0){bottomRangeFloor=y_centroids[ii]-halfHeight;bottomRangeCeiling=y_centroids[ii]+halfHeight;}									bottomCentroids[bcount++]=ii;									aveBottomCentroidY+=y_centroids[ii];								}							}							if(bottomRangeFloor<topRangeCeiling){errorReport="true";}						}						while(tcount < minCount && errorReport !="true"){							tcount=0; aveTopCentroidY=0;							topRangeFloor=topRangeCeiling; topRangeCeiling=topRangeCeiling+aveHeight*2;							for(ii=0;ii<x_centroids.length;ii++){								if(y_centroids[ii] < topRangeCeiling && y_centroids[ii] > topRangeFloor){									if(tcount==0){topRangeFloor=y_centroids[ii]-halfHeight;topRangeCeiling=y_centroids[ii]+halfHeight;}									topCentroids[tcount++]=ii;									aveTopCentroidY+=y_centroids[ii];								}							}							if(topRangeCeiling>bottomRangeFloor){errorReport="true";}						}						collect_garbage(50);						topBorder=0;						leftBorder=0;						rightBorder=0;						bottomBorder=0;					}					else{errorReport = "true";rightBorder=0;leftBorder=0;bottomBorder=0;topBorder=0;colValue=0;aveWidth=0;aveHeight=0;} // to few particles to analyze					aveDistance=0;					if(errorReport=="false"){						aveLeftCentroidX=aveLeftCentroidX/lcount;						aveRightCentroidX=aveRightCentroidX/rcount;						aveBottomCentroidY=aveBottomCentroidY/bcount;						aveTopCentroidY=aveTopCentroidY/tcount;						//print("aveLeftCentroidX = "+aveLeftCentroidX+"\naveRightCentroidX = "+aveRightCentroidX+"\naveBottomCentroidY = "+aveBottomCentroidY+"\naveTopCentroidY = "+aveTopCentroidY);						// should now have all centroid indices that fall within top and bottom rows of selection						// as well as the left and right columns.  now need to get average distance between a centroid and 						// its nearest neighbor.....												aveDistance=aveDistance+findAveDistance(leftCentroids,x_centroids,y_centroids,width, lcount);						aveDistance=aveDistance+findAveDistance(rightCentroids,x_centroids,y_centroids,width,rcount);						aveDistance=aveDistance+findAveDistance(topCentroids,x_centroids,y_centroids,width,tcount);						aveDistance=aveDistance+findAveDistance(bottomCentroids,x_centroids,y_centroids,width,bcount);						aveDistance=aveDistance/4;						//if(showDebug){showMessageWithCancel(aveDistance);}						startY=aveTopCentroidY-(aveDistance/2);						startX=aveLeftCentroidX-(aveDistance/2);							//if(showDebug){showMessageWithCancel("startX = "+startX+", startY = "+startY+"\naveTopCentroidY = "+aveTopCentroidY+"\naveDistance = "+aveDistance);}							topBorder=findBorder(startX, startY, xWidth, aveDistance, width, height,rows,cols,colValue);						leftBorder=findBorder(startX, startY, aveDistance, yHeight, width, height,rows,cols,colValue);						collect_garbage(50);						startY=aveBottomCentroidY-(aveDistance/2);						bottomBorder=findBorder(startX, startY, xWidth, aveDistance, width, height,rows,cols,colValue);						errorMessage="";						startY=aveTopCentroidY-(aveDistance/2);						startX=aveRightCentroidX-(aveDistance/2);						rightBorder=findBorder(startX, startY, aveDistance, yHeight, width, height,rows,cols,colValue);						// ensure the borders we select are within the bounds of the image and that the findBorder function did not return an error (returns -1 if error)						if(topBorder <= 0 || leftBorder <= 0 || bottomBorder > height || rightBorder > width || bottomBorder <= 0 || rightBorder <= 0){ 						//	errorReport = "true";						//	errorLog=errorLog+"Plate: "+files[xx]+" has too many blank regions in plate to accurately fine crop image.\nIf you fine crop this image manually it may still be able to have its colonies measured.\n\n";						}					}					x_centroids='';					y_centroids='';					leftCentroids='';					rightCentroids='';					topCentroids='';					bottomCentroids='';					collect_garbage(50);					if(showDebug){showMessageWithCancel("errorReport = "+errorReport+"\nselection:\nleft Border = "+leftBorder+"\ntop border = "+topBorder+"\nwidth = "+width+"\nheight = "+height);}					width=rightBorder-leftBorder;					height=bottomBorder-topBorder;					if(width <= 0 || height <= 0){errorReport="true";}					if(errorReport=="false"){						if(density==384 || density == 96){leftBorder-=5; topBorder-=5; width+=10; height+=10;} // add some padding						else if(density==1536 || density == 2304){leftBorder-=3; topBorder-=3; width+=6; height+=6;} // add some padding						makeRectangle(leftBorder, topBorder, width, height);						run("Crop");						// trimmedDimmensions = dimensions used to crop / trim image. Index 0 = left corrdinate, 1 = top, 2 = width, 3 = height						trimmedDimensions = trimBorder(width,height,colValue, "white", 1, 1, 2);							if(trimmedDimensions[0] < 0 && trimmedDimensions[1] < 0 && trimmedDimensions[2] < 0 && trimmedDimensions[3] < 0){							close_window(files[xx]);							setBatchMode(false); // turn off batch mode							// re open image so user can view it							onOpenMethods(cur_path,0, "yes",density, '',false); // prepare image for processing							tryManual=getBoolean("There was an issue fine cropping the current image. Would you like to try to fix this issue.\n\nTo run the manually crop this image click 'Yes'. To skip this image click 'No'. To exit this macro click 'Cancel'.");							if(tryManual){								angle=userSelectionAlignAndCrop(files[xx],false);								getSelectionBounds(leftBorder, topBorder, width, height);								rectangleDims=newArray(leftBorder,topBorder,width,height); // top left position + width and length of rectangle								close_window(files[xx]);								setBatchMode(batchMode); 								onOpenMethods(cur_path,angle,"yes",density, rectangleDims,thresholdImages); // prepare image for processing							}							else{								errorReport="true";								// will store fine_crop_errors images								moveImage(current_dir, error_dir, files[xx], 0, 0, width, height,0, "true"); // move image to error directory								errorLog=errorLog+"Plate: "+files[xx]+" was not cropped, issues determining colony borders.\n\n";							}						}						else{							if(showDebug){showMessageWithCancel("selection:\nleft Border = "+leftBorder+"\ntop border = "+topBorder+"\nwidth = "+width+"\nheight = "+height+"\n\n\nNew left = "+trimmedDimensions[0]+"\nNew Top: "+trimmedDimensions[1]+"\nNew width = "+trimmedDimensions[2]+"\nNew Height = "+trimmedDimensions[3]);}							leftBorder=leftBorder+trimmedDimensions[0];							topBorder=topBorder+trimmedDimensions[1];						}					}					else{						close_window(files[xx]);						setBatchMode(false); // turn off batch mode						// re open image so user can view it						onOpenMethods(cur_path,0, "yes",density, '',false); // prepare image for processing						tryManual=getBoolean("There was an issue fine cropping the current image. Would you like to try to fix this issue.\n\nTo run the manually crop this image click 'Yes'. To skip this image click 'No'. To exit this macro click 'Cancel'.");						if(tryManual){							angle=userSelectionAlignAndCrop(files[xx],false);							getSelectionBounds(leftBorder, topBorder, width, height);							rectangleDims=newArray(leftBorder,topBorder,width,height); // top left position + width and length of rectangle							close_window(files[xx]);							setBatchMode(batchMode);							onOpenMethods(cur_path,angle,"crop_me",density, rectangleDims,thresholdImages); // prepare image for processing							errorReport = "false";						}						else{							// will store fine_crop_errors images							moveImage(current_dir, error_dir, files[xx], 0, 0, width, height,0, "true"); // move image to error directory							setBatchMode(batchMode);							errorLog=errorLog+"Plate: "+files[xx]+" was not cropped, issues determining colony borders.\n\n";								}					}				}							collect_garbage(50);							// ------------------------------------				// END LOOKING FOR BORDERS AND FINE CROP				// ------------------------------------				if(showDebug){showMessageWithCancel("Fine-Cropping complete. Begin validating plate integrity.");}				// ------------------------------------				// BEGIN VALIDATION OF ALIGNMENT AND CROPPING PROCEDURES				// ------------------------------------				if(errorReport == "false"){					// validateAlignAndCrop checks that newly fine cropped image has its colonies arranged in a neat grid format					// if it is not it trys to rotate the image sligthly to the left and right in a stepwise fashion					// at each step it checks the integrity of the grid format. At the end of the function if it is					// determined that the colonies lie in a neat grid the image is saved in the 'success' folder, otherwise					// it is saved in the 'error' folder					width=getWidth();					height=getHeight();					// check plate grid via plot profile 					goodWidth = checkPlateProfile(rows, cols, width, true);					goodHeight = checkPlateProfile(rows, cols, height, false);					intervene=false;					if(showDebug){showMessageWithCancel("goodWidth = "+goodWidth+"\ngoodHeight = "+goodHeight);}					if(goodWidth && goodHeight){						// check that newly fine cropped image has its colonies arranged in a neat grid format						checkPlate_info=newArray(3); // index 0 = column mean, index 1 = horizonatal, index 2 = boolean value (true == success)						checkPlate_info=checkPlate(density, width, height, aveWidth, aveHeight, aveDistance, colValue, rows, cols);						collect_garbage(50);						// if we failed checkPlate, try to manually rotate the image several times, after each 						// rotation run checkPlate, try to determine the angle that results in the best results from						// checkPlate						if( !checkPlate_info[2] ){							counter=1;							fine_adjust_angle=0.1;							step=0.1;							best_v=checkPlate_info[0];							best_h=checkPlate_info[1];							best_angle=0;							stupid_move=0; // tells us if things are getting worse by rotating the image							while(stupid_move<2 && counter<15 ){								// rotate slightly and re-threshold								run("Rotate... ", "angle="+fine_adjust_angle+" interpolation=Bilinear");								thresholdImage();								//print ("angle="+fine_adjust_angle);								// see if it made a difference								checkPlate_info=checkPlate(density, width, height, aveWidth, aveHeight, aveDistance, colValue, rows, cols);								// if it made a difference in correct direction, then keep it								// else dump it								if( (checkPlate_info[0] < best_v && checkPlate_info[1] < best_h) || ( (checkPlate_info[0]+checkPlate_info[1]) < (best_v+best_h) )){									best_v=checkPlate_info[0];									best_h=checkPlate_info[1];									best_angle=fine_adjust_angle;								}								else{									run("Rotate... ", "angle="+(fine_adjust_angle*-1)+" interpolation=Bilinear");									thresholdImage();									stupid_move++;								}								fine_adjust_angle=fine_adjust_angle+step;								// if rotating in one direction was a mistake, then try the other;								if(stupid_move>=2 && fine_adjust_angle>0){stupid_move=0;fine_adjust_angle=-0.1; step=-0.1;}								counter++;								collect_garbage(50);								//print("stupid = " + stupid_move + ", counter= "+counter);							}							//print ("best_angle="+best_angle);							angle+=best_angle;							rectangleDims=newArray(leftBorder,topBorder,width,height); // top left position + width and length of rectangle							onOpenMethods(cur_path,angle,"crop_me",density, rectangleDims,true);							checkPlate_info=checkPlate(density, width, height, aveWidth, aveHeight, aveDistance, colValue, rows, cols);							if(showDebug){showMessageWithCancel("checkPlate_info[2]:\n"+checkPlate_info[2]+"\nAngle = "+angle);}							if(checkPlate_info[2]!=1){								intervene=true;								//if(showDebug){showMessageWithCancel(errorLog);}							}							// after messing with angle a bit the image passed validation, move to success_dir							else{moveImage(current_dir, success_dir, files[xx], leftBorder, topBorder, width, height, angle, "true");}						}						// image passed validation, move to success_dir						else{	moveImage(current_dir, success_dir, files[xx], leftBorder, topBorder, width, height, angle, "true");}							}					else{	intervene=true;	}					if(intervene){						// give user one last chance to intervene						close_window(files[xx]);						setBatchMode(false); // turn off batch mode						// re-open image so user can view it						onOpenMethods(cur_path,angle, "yes",density, '',false); // prepare image for processing						makeRectangle(leftBorder, topBorder, width, height);						imageGood=getBoolean("There was an issue validating the 'fine-cropping' of this image.\n\nDoes the image being displayed apprear to be aligned with a selection box lined up with the edges of expected colony growth? Remember 'expected colony growth' INCLUDES blank rows and columns.\n\nTo exit this macro click 'Cancel'.");						if(imageGood){	moveImage(current_dir, success_dir, files[xx], leftBorder, topBorder, width, height, angle, "true");	}						else{							manualAdjust=getBoolean("Would you like to manually adjust the borders of the selection box yourself?\n\nTo exit this macro click 'Cancel'.");							if(manualAdjust){								waitForUser("Verify Crop Selection and image alignment", "Please verify the image alignment (ie rotation) and dimensions of the selection box. If it is off, adjust it appropriately. When you are done, click 'OK'.");								getSelectionBounds(leftBorder, topBorder, width, height);								// need to save image to retain angle adjustment (if any)								run("Save");								moveImage(current_dir, success_dir, files[xx], leftBorder, topBorder, width, height, angle, "true");							}							else{								// image did not pass validation, move it to error directory								moveImage(current_dir, error_dir, files[xx], leftBorder, topBorder, width, height, angle, "true"); 								errorLog=errorLog+"Plate: "+files[xx]+" did not pass fine crop validation test, image not cropped.\n\n";							}						}						// make sure window is closed						close_window(files[xx]);						setBatchMode(batchMode);					}				}				//if(showDebug){showMessageWithCancel("grid check done");}				// ------------------------------------				// END VALIDATION OF ALIGNMENT AND CROPPING PROCEDURES				// ------------------------------------			} // if(cropMode != "Manual")			else{				angle=userSelectionAlignAndCrop(files[xx], true);				moveImage(current_dir, success_dir, files[xx], 0, 0, 0, 0, 0, "false");			}		}		changeProgress("Fine Crop Progress",xx, files.length, 0, 255,127); // Spring Green		run("Clear Results");		setBatchMode(batchMode); 	}	print("\\Clear"); // clear log file	if(errorLog != ""){ // print and save error log if it exists.		print (errorLog);		selectWindow("Log");		saveAs("txt", home_dir+"fine_crop_errors/error_notes");		errorLog="";		close_window("Log");	}	close_window("Fine Crop Progress");}// function : analyzeParticles// inputs:// minSize -> minimum particle size (area) to consider// minCirc -> minimum particle circularity to consider// exclude -> if exclude == "exclude" then colonies that overlap with the // 						selection are not considered. // purpose:// This function will select the entire area of the image and run the ImageJ "Analyze Particles"// method, based on the variables passed to it.function analyzeParticles(minSize,minCirc,exclude){	run("Select All");	run("Analyze Particles...", "size="+minSize+"-Infinity circularity="+minCirc+"-1.00 show=Nothing display "+exclude+" clear");}// function : calculateBackground// inputs:// left -> x coordinate of left most pixel// top -> y coordinate of top most pixel// right -> x coordinate of right most pixel// bottom -> y coordinate of bottom most pixel// purpose:// calculates the median pixel value of the pixels at (left,top), (left,bottom)// (right, top), (right,bottom)function calculateBackground(left,top,right,bottom){	// get calibrated pixel values of the sides of current selection	// Set background to median value of the 4 corners of the selection	// This method will allow us to avoid a false reading that	// could occur if the colony slightly overlaps with one of the corners	values=newArray(4);	background=0;	values[0]=calibrate(getPixel(left,top));	values[1]=calibrate(getPixel(left,bottom));	values[2]=calibrate(getPixel(right,top));	values[3]=calibrate(getPixel(right,bottom));			//if(showDebug){showMessageWithCancel(left+", "+top+"\n"+values[0]+", "+values[1]+", "+values[2]+", "+values[3]+"\n"+background+"\n g_height = "+g_height+"\ng_width= "+g_width);}	//values=newArray( calibrate(getPixel(left,top)), calibrate(getPixel((right,top)), calibrate(getPixel(left,bottom)), calibrate(getPixel(right,bottom)));	Array.sort(values);	background=(values[1]+values[2])/2; // set background to median value	background+=background*0.05; // add an addition 5% to background value	//if(showDebug){showMessageWithCancel(left+", "+top+"\n g_height = "+g_height+"\ng_width= "+g_width+"\n"+values[0]+", "+values[1]+", "+values[2]+", "+values[3]+"\n"+background);}	return background;}// function : centerSelectionOverColony// inputs: NONE// purpose:// attempts to center current selection in a way that will maximize the mean value// assumes circular colonyfunction centerSelectionOverColony(imageWidth, imageHeight, i,j){	//pos =  (i*48+j+1);	type = selectionType();	if(type < 0){return false;} // no selection	getSelectionBounds(x, y, width, height);	run("Measure");	min=getResult("Min");	max=getResult("Max");	mean=getResult("Mean");	//if(showDebug && pos > 2256){showMessageWithCancel("before"+"\ni = "+i+"\nj = "+j);}	newX = x;	newY = y;	if(newX<0){newX=1;}	else if(newX+width>imageWidth){newX=imageWidth-width;}	if(newY<0){newY=1;}	else if(newY+height>imageHeight){newY=imageHeight-height;}	newX = minimizeEdges(false,newX, newY, width, height,imageWidth);	newY = minimizeEdges(true,newX, newY, width, height, imageHeight);	makeRectangle( newX, newY, width, height);	//if(showDebug  && pos > 2256){	showMessageWithCancel(newX+","+newY+" --> adjusted rectangle\npos = "+pos+"\ni = "+i+"\nj = "+j);	}}function minimizeEdges(setAltKey, x, y, width, height, imageDimension){	yMovement=0;	xMovement=0;		newHeight=round(height+0.5);	newWidth=round(width+0.5);		if(setAltKey){		length=height;		maxAdjust=length*0.25;		maxNegAdjust=maxAdjust;		maxPosAdjust = maxAdjust;		yMovement=1;		// make sure that we do not check beyond the bounds of the image		if(maxAdjust+y+height > imageDimension){	maxPosAdjust = imageDimension-y-height;	}//if(maxPosAdjust<0){maxPosAdjust=0;}}		if(y-maxAdjust < 0){	maxNegAdjust = y;	}		initialPosition = y;		newHeight = round(maxNegAdjust+maxPosAdjust+height+0.5);	}	else{		length=height;		maxAdjust=length*0.25;		maxNegAdjust=maxAdjust;		maxPosAdjust = maxAdjust;		xMovement=1;		// make sure that we do not check beyond the bounds of the image 		if(maxAdjust+x+width > imageDimension){	maxPosAdjust = imageDimension-x-width;	}//if(maxPosAdjust<0){maxPosAdjust=0;}}		else if(x-maxAdjust < 0){maxNegAdjust=x;}		initialPosition = x;		newWidth = round(maxNegAdjust+maxPosAdjust+width+0.5);	}	min=256;	lastValue=256;	adjuster=0;	ax = round(x-(maxNegAdjust*xMovement)+0.5);	ay = round(y-(maxNegAdjust*yMovement)+0.5);	makeRectangle( ax, ay, newWidth, newHeight);	if(setAltKey){setKeyDown("alt");}	profile = getProfile();	setKeyDown("none");		profileLength=profile.length;	limit = round(maxNegAdjust+maxPosAdjust);	if(limit+length > (profileLength-1)){		limit=profileLength-length-1;	}	direction = 1;	for(j=1; j<=2; j++){		//if(pos>2256){showMessageWithCancel("direction = "+direction+"\nmaxNegAdjust = "+maxNegAdjust+"\nlimit = "+limit+"\nj = "+j+"\nlength = "+length+"\nsetAltKey = "+setAltKey);}		count = 0;		for(i=maxNegAdjust; i	< limit; i++){			index = maxNegAdjust + count*direction;			count+=1;			first=profile[index];			last=profile[index+length]; // index 38 out of 0-30 range			meanValue = (first+last)/2;					//if(pos>2256){showMessageWithCancel( ax+","+ ay+","+ width+","+height+"\nfirst = "+first+"\nlast = "+last+"\nmean = "+meanValue+"\nminValue = "+min+"\nmaxAdjust = "+maxAdjust+"\ni = "+i+"\ndirection = "+direction+"\nlimit = "+limit+"\nj = "+j+"\nindex = "+index+"\nlength = "+length);}			// kick out of loop if we are not improving			if(meanValue > lastValue){i=imageDimension+5;}			else if(meanValue<min){				min=meanValue;				adjuster=count*direction;			}			lastValue=meanValue;		}		direction=-1;		limit = maxNegAdjust*2;		if(maxNegAdjust+length > (profileLength-1)){			maxNegAdjust=profileLength-length-1;		}	}	return (initialPosition+adjuster);}// function : changeProgress// inputs:// windowTitle -> title of progressBar window// fileNumber -> number we are currently working on// totalNumber -> total number of objects we are processing// r, g, b -> rgb values for the background of the bar that is indicating progress// purpose:// changes progress indicated on progess bar by painting over it and writing the new progress valuefunction changeProgress(windowTitle,fileNumber,totalNumber,r,g,b){	if(isOpen(windowTitle)){ // if a window is open with a title == windowTitle		saveSettings(); // save current settings		if(!showDebug){setBatchMode(false);}  // set batch mode to false so that the image we are about to create is displayed		setColor(255, 255, 255);  		fillRect(0, 0, 400, 30); // fill in background completely with white		setColor(r, g, b);		fileNumber++;		percentage=fileNumber/totalNumber; // add 1 to file number since file number starts at 0		fillRect(0, 0, (400*percentage), 30); // draw baar indicating progress		setColor(0, 0, 0);		drawString(fileNumber+" of "+totalNumber+" = " + (round((percentage*100))) + "%", 200, 25); // write in progress		if(!showDebug){setBatchMode(true);} // set batch mode back to true		restoreSettings; // restore settings	}}// function : checkIfBorderCentered// inputs:// x1, y1 -> x and y cooridate of selection box that is drawn to determine if we are centered over border colonies// w, h -> width and height dimensions of that selection box// direction -> direction should == "t_b" if we are checking the top or bottom border, any other value for left and right borders// rows and cols = number of rows and columns that make up the grid of colonies// iterator -> should be 1 or -1 to indicate if we should move towards larger or smaller values of x and y // colValue -> should be 0 or 255 to indicate the color value of a particle// returns:// x or y value at outermost edge or a border row or column of colonies// purpose:// draws a selection box with dimensions x1,y1,w,h. If this selection box does not overlap with any particles this // function will just return the original x or y value (depending on what border we are examining). Otherwise the function// will attempt to find the innermost edge or the particles in the selection box and then move a selection line outwards until// it no longer overlaps with any particles (subject to the BorderValidationThreshold threshold). It then returns the corresponding// x or y position of the slection line depending on what border is being examined function checkIfBorderCentered(x1,y1,w,h,direction,rows,cols,iterator,colValue){	val=getWidth()+getHeight()*iterator*-1; // initialize to very large or low value depending on value of iterator	originalY1=y1;	originalX1=x1;	makeRectangle(x1, y1, w, h);	// analyze particles in selection box, exclude any particles that overlay with borders of selection box (aka exclude on edges)	run("Analyze Particles...", "size="+sizeCutoff+"-Infinity circularity=0.55-1.00 show=Nothing clear exclude");	totalParticles=nResults;	// analyze particles in selection box, include internal particles and any that overlay with borders of selection box (do NOT exclude on edges)	run("Analyze Particles...", "size="+sizeCutoff+"-Infinity circularity=0.55-1.00 show=Nothing clear record");	base = nResults;	addOn=0; // if we are looking for the bottom or right edge we do not want the start of the particle, we want the start plus the height or width	if(base>totalParticles){ // means that the selection rectangle is overlapping some colonies		totalParticles=nResults;		// find the inner-most edge position of particles that we are overlapping (x or y value)		for (i=0; i<nResults; i++){						if(direction=="t_b"){start=getResult("YStart",i);addOn=getResult("Height",i);} // interested in starting y position of particle			else{start=getResult("XStart",i); addOn=getResult("Width",i);} // interested in starting x position of particle			//if(showDebug){showMessageWithCancel("Val = "+val+"\nStart = "+start+"\niterator = "+iterator+"\nnResults"+nResults);}			if(iterator<0 && start < val){val = start;}			else if(iterator>0 && start > val){val = start+addOn;}		}				// now that we have the inner most edge of particles on the border, draw a selection line and move it toward the edge 		// until it no longer overlaps with any particles		BorderValidationThreshold=10;		if(colValue == 0){modifier=255;}		else{modifier=0;}		if(direction=="t_b"){y1=val;y2=val;x2=w;}		else{x1=val;x2=val;y2=h;}		thickness = minOf(w,h);		lineValue=abs(modifier-drawAndMeasureSelectionLine(x1,y1,x2,y2));		if(showDebug){showMessageWithCancel("x1 = "+x1+"\ny1 = "+round(y1-0.5)+"\n"+y1+"\nx2 = "+x2+"\ny2 = "+y2);}		counter=0;		// perhaps I should couple a threshold with a check to see if the value goes down and then back up?...DONE SEE VARIABLES 'backupCheck' and 'upSteps'		backupCheck=false;		upSteps=0;		last=0;		while(lineValue > BorderValidationThreshold && counter < thickness && !backupCheck){			if(direction=="t_b"){				y1=y1+(1*iterator);				y2=y1;			}			else{				x1=x1+(1*iterator);				x2=x1;			}			lineValue=abs(modifier-drawAndMeasureSelectionLine(x1,y1,x2,y2));			if(lineValue > last){upSteps++;}			if(upSteps>=5){backupCheck=true;}			last=lineValue;			counter++;		}		if(counter > thickness){ // could not find edge, revert to original state			y1=originalY1;			x1=originalX1;		}		if(showDebug){showMessageWithCancel(val+"\nx1 = "+x1+"\ny1 = "+round(y1-0.5)+"\n"+y1+"\nlineValue = "+lineValue+"\nthickness = "+thickness+"\noriginal = "+originalX1+"\ncolValue = "+colValue+"\nmodifier = "+modifier+"\nbackUpCheck = "+backupCheck);}			}	else if(iterator>0){y1+=h;x1+=w;}	if(direction=="t_b"){return y1;}	return x1;}// function : checkIfStack// purpose:// checks to see if image is a stack, if it is, this function will flatten itfunction checkIfStack(){	if(nSlices > 1){		otitle=getTitle();		run("Z Project...", "start=1 stop=3 projection=[Average Intensity]");		nTitle = getTitle();		close_window(otitle)		selectWindow(nTitle);	}}// function : checkParticles// input:// density -> density of colonies on plate (number of cells that make up grid of colonies)// purpose:// if we have a low number of particles on the plate, invert the image and see if that increase the count.// If inversion results in a lower number of particles, invert back to original statefunction checkParticles(density){	halfDensity= density / 2;	if(nResults<halfDensity){		base=nResults;		run("Invert");		analyzeParticles(20,0.8,"exclude");		if(nResults<base){run("Invert");}		run("Clear Results");	}}// function : checkPlate// input:// density -> number of cells that make of the grid of colonies// width -> width of image// height -> height of image// aveWidth -> average width of a particle (colony)// aveHeight -> average height of a particle (colony)// avDistance -> average distance between adjactent colony centroids// colValue -> the value of a particle, should be 0 or 255// rows and cols = number of rows and columns that make up the grid of colonies// returns:// results array indicating success or error. Indices = 0 --> column mean, 1 --> row mean, 2 --> boolean value, true == passed validation// purpose:// validate that colonies (particles) lie in an ordered grid across imagefunction checkPlate(density, width, height, aveWidth, aveHeight, aveDistance, colValue, rows, cols){	// need to find edge of colonies before doing this because sometimes the image borders are a few pixels off from the colony borders	// IDEA: start in middle of image. Find row or column of colonies (already have average colony height / width [aveWidth, aveHeight] and space between cols/rows [aveDistance] )	// in center of plate. Line up on white speace imediately before or after column or row of colonies. To do this draw a small selection box, analyze the particles	// take 1st particle (reference) iterate over the others and keep the centroid values for particles that lie within 1 colony width (aveWidth) or height (aveHeight)	// of the reference particle. The averaage of these centroid values (x and y independently) should be approximately the center of a row or col of colonies	// once we have this info we can draw a selection line in this "trough" between colonies and measure (should be really high or low depending on what the black value is).	// Once measurement is done move over 1 row / column width and measure again. Stop when the selection line you are about to draw exceeds the borders of the image. 	// Accumulate all measurements and take average. If the resulting average is below the set threshold then the image has been successfully validated 	if(colValue == 0){modifier=255;}	else{modifier=0;}	results=newArray(3);		centerPlateWidth = width/2;	centerPlateHeight = height/2;	cellHeight = height/rows;	cellWidth = width/cols;		// find center of a column of colonies...	iLoop=0; // infinite loop checker	startHeight=cellWidth;	heightLength=height-(cellHeight*2);;	colStartX=centerPlateWidth-cellWidth;	col_Xwidth=2*cellWidth;	makeRectangle(colStartX, startHeight, col_Xwidth, heightLength);	if(showDebug){showMessageWithCancel("selection");}	run("Analyze Particles...", "size=5-Infinity circularity=0.80-1.00 show=Nothing exclude clear");	while(nResults < 2 && iLoop <= 15 && colStartX>0 && col_Xwidth<width){ // if we did not measure any particles make selection box bigger and try again		makeRectangle(colStartX, startHeight, col_Xwidth, heightLength);		run("Analyze Particles...", "size=5-Infinity circularity=0.80-1.00 show=Nothing exclude clear");		colStartX-=cellWidth;		col_Xwidth+=cellWidth;		iLoop++; 	}	if(iLoop == 15){ // hit loop limit, cannot find any particles return a result indicating validation error		results[0]=0;		results[1]=0		results[2]=2;		return results;	}	baseX=0;	xAveCen=0;	xCeil=0; xFloor=0;	xCounter=0;	for (i=0; i<nResults; i++){			currentX = getResult("X",i);			if(i==0){			baseX=currentX;			xAveCen=xAveCen+baseX; 			xCounter++;			xCeil=baseX+aveWidth/2; xFloor=baseX-aveWidth/2;		}		else if(currentX<xCeil && currentX>xFloor){ // we must be in same column			xAveCen=xAveCen+currentX;			xCounter++;		}	}	xAveCen=xAveCen/xCounter;	leftTrough = xAveCen - aveDistance / 2;	rightTrough = xAveCen + aveDistance / 2;		// find center of a row of colonies...	iLoop=0; // infinite loop checker	startWidth=cellHeight;	widthLength=width-(cellWidth*2);	rowStartY=centerPlateHeight-cellHeight;	row_Ywidth=cellHeight*2;	makeRectangle(startWidth, rowStartY, widthLength, row_Ywidth);	if(showDebug){showMessageWithCancel("selection");}	run("Analyze Particles...", "size=5-Infinity circularity=0.80-1.00 show=Nothing exclude clear");	while(nResults < 2 && iLoop <= 15 && rowStartY>0 && col_Xwidth<width){ // if we did not measure any particles make selection box bigger and try again		makeRectangle(startWidth, rowStartY, widthLength, row_Ywidth);		run("Analyze Particles...", "size=5-Infinity circularity=0.80-1.00 show=Nothing exclude clear");		rowStartY-=cellHeight;		col_Xwidth+=cellHeight;		iLoop++; 	}	if(iLoop == 15){ // hit loop limit, cannot find any particles return a result indicating validation error		results[0]=0;		results[1]=0;		results[2]=false; //results[2]=2;		return results;	}		baseY=0;	yAveCen=0;	yCounter=0;	yCeil=0; yFloor=0;	yCounter=0;	for (i=0; i<nResults; i++){			currentY = getResult("Y",i);				if(i==0){			baseY=currentY; 			yAveCen=yAveCen+baseY;			yCounter++;			yCeil=baseY+aveHeight/2; yFloor=baseY-aveHeight/2;		}		else if(currentY<yCeil && currentY>yFloor){ // we must be in same column			yAveCen=yAveCen+currentY;			yCounter++;		}	}	yAveCen=yAveCen/yCounter;	topTrough = yAveCen - aveDistance / 2;	bottomTrough = yAveCen + aveDistance / 2;		// now I should have the position of 4 "troughs" (aka space between colonies) positioned somewhere in the middle of the	// image. I can now draw a selection line on these troughs and run the measure command. The area value that the measure	// command returns should give us an idea if the selection truely lies in a trough or if it overlaps any colonies. 	// Move these selection line out towards the edge of the image by a distance equivalent to the expected width (or height)	// of a cell in the grid layout of the colonies (ie height of image / number of rows or width / # columns) and run the 	// measure command at each step (these positions should all be troughs) -- [note: could also use aveDistance as the	// iterator instead of cell width or hieght but I feel that you would get less reliable results]. The average of all 	// the Area values for all of these troughs should tell us if we have a nice grid layout (meaning the selection lines, 	// which should be in troughs do not overlap too much with colonies)		// check troughs left and right of center	columnMean=0;	troughsExamined=0;	mean=0;	iterator=cellWidth*2;	while(leftTrough>0 || rightTrough<width){		if(leftTrough>0){			mean=drawAndMeasureSelectionLine(leftTrough, cellHeight, leftTrough, heightLength);			columnMean+=mean;			troughsExamined++;			leftTrough-=iterator;			//if(showDebug){showMessageWithCancel("left\n"+leftTrough+"\n"+cellHeight+"\n"+leftTrough+"\n"+heightLength);}		}		if(rightTrough<width){			mean=drawAndMeasureSelectionLine(rightTrough, cellHeight, rightTrough, heightLength);			columnMean+=mean;			troughsExamined++;			rightTrough+=iterator;			//if(showDebug){showMessageWithCancel("right");}		}	}	columnMean = abs(modifier-columnMean/troughsExamined);	// check troughs to the above and below center	rowMean=0;	troughsExamined=0;	iterator=cellHeight*2;	while(topTrough>0 || bottomTrough<height){		if(topTrough>0){			mean=drawAndMeasureSelectionLine(cellWidth, topTrough, widthLength, topTrough);			rowMean+=mean;			troughsExamined++;			topTrough-=iterator;			//if(showDebug){showMessageWithCancel("above");}		}		if(bottomTrough<height){			mean=drawAndMeasureSelectionLine(cellWidth, bottomTrough, widthLength, bottomTrough);			rowMean+=mean;			troughsExamined++;			bottomTrough+=iterator;			//if(showDebug){showMessageWithCancel("below");}		}	}	rowMean = abs(modifier-rowMean/troughsExamined);		results[0]=columnMean;	results[1]=rowMean;	if(showDebug){showMessageWithCancel("columnMean = "+columnMean+"\nrowMean = "+rowMean);}	if(columnMean<validationThreshold && rowMean<validationThreshold){		if(showDebug){showMessageWithCancel("Plate Validated!!!");}		results[2]=true;}	else{		if(showDebug){showMessageWithCancel("Plate failed validation :(");}		results[2]=false;}	return results;}// function : checkPlateProfile// input:// rows and cols => expected number rows and columns in the grid of colonies// dimension -> width or height of image (if isWidth == true this should be the width)// isWidth -> this == true if we are checking the width// Returns:// true if it thinks the plate has been fine cropped appropriately, false otherwise// Purpose:// Run plot profile on the image, determine the avereage width of a column (or row) of colonies and then multiple// that value times the number of columns (or rows) expected based on the density entered by the user. This should yield the // expected width (or height) of the image, if the actual width and height are close to the calculated width and height then// return truefunction checkPlateProfile(rows, cols, dimension, isWidth){	tolerance=0.05;	run("Select All");	if(isWidth){	profile=getProfile(); } // get horizontal profile	else{		setKeyDown("alt"); // Set alt key down for vertical profiles		profile=getProfile(); // get verticle profile		setKeyDown("none"); //  reverse setKeyDown command	}	average=getArrayAverage(profile); // get average value of profile	numDips=cols*cols; // assume that the maximum number of "profile dips" can be no > cols*cols	index=0; // starting index	last=profile[index]; // last == the "last" value examined (NOT THE LAST VALUE IN THE ARRAY)	inUpArea=true; // this == true if the profile value is increasing	index+=1; // increase index by 1	dipIndex=-1; // initialize dipIndex to -1	sideOfCols=newArray(numDips);	Array.fill(sideOfCols, -1); // fill colWidths with -1	//showMessageWithCancel("isWidth = "+isWidth);	// determine position (sideOfCols), and width of dips	while(index < profile.length && index > 0){		if(profile[index] < average){			if(inUpArea){dipIndex++;}			if(dipIndex < sideOfCols.length){	sideOfCols[dipIndex]=index;	}			inUpArea=false;		}		else{inUpArea=true;}		last=profile[index];		index+= 1;	}	sideOfCols=trimArray(sideOfCols);	widthOfColumn=newArray(sideOfCols.length);	debugMessage="";	for(i=0;i<sideOfCols.length;i++){		if(i==0){widthOfColumn[i]=sideOfCols[i];}		else{widthOfColumn[i]=sideOfCols[i]-sideOfCols[i-1];}		//if(showDebug){showMessageWithCancel("widthOfColumn[i] = "+widthOfColumn[i]+", sideOfCols[i] = "+sideOfCols[i]);}	}	if(widthOfColumn.length < 1){return false;}	if(isWidth){		expectedImageWidthOrHeight = medianArrayValue(widthOfColumn) * cols;	}	else{expectedImageWidthOrHeight = medianArrayValue(widthOfColumn) * rows;}	ratio = dimension / expectedImageWidthOrHeight;	if(showDebug){showMessageWithCancel("Median = "+medianArrayValue(widthOfColumn)+"\nexpectedImageWidthOrHeight = "+expectedImageWidthOrHeight+"\nDimension = "+dimension+"\nRatio = "+ratio+"\nisWidth? = "+isWidth);}	if(ratio >= (1-tolerance) && ratio <= (1+tolerance)){		if(showDebug){showMessageWithCancel("RETURNING TRUE!!!\nMedian = "+medianArrayValue(widthOfColumn)+"\nexpectedImageWidthOrHeight = "+expectedImageWidthOrHeight+"\nDimension = "+dimension+"\nRatio = "+ratio+"\nisWidth? = "+isWidth);}		return true;	} // good image, return true	if(showDebug){showMessageWithCancel("RETURNING FALSE!!\nMedian = "+medianArrayValue(widthOfColumn)+"\nexpectedImageWidthOrHeight = "+expectedImageWidthOrHeight+"\nDimension = "+dimension+"\nRatio = "+ratio+"\nisWidth? = "+isWidth);} 	return false;}// function : checkThreshold// input:// currentFullPath -> current full directory path that image is in// errorFolderFullPath -> where to place this image is the user decides the image is no good// currentFile -> current image name// Returns:// "true" indicating that everything is okay or error message// purpose:// alerts user to the possiblity that their image was threshold improperly (bad values)// and asks them if they would like to continue processing it, or mark it as a "error" imagefunction checkThreshold(currentFullPath, errorFolderFullPath, currentFile){	// currentFullPath and errorFolderFullPath are full paths, currentFile is just the file name.	close();	if(!showDebug){setBatchMode(false);}	open(currentFullPath+currentFile);	checkIfStack(); // checks to see if image is a stack, if it is this function will flatten it	convertToBlackWhite(0);	run("Set Scale...", "unit=");	Dialog.create("Possible Threshold Error"); // create dialog to retreive user input	Dialog.addMessage("There may be an issue with the image currently being processed.\nAre there are any large artifacts on the current plate that obscure several of the colonies on the current plate?\n \nIf you select 'Yes' the current image will be moved to "+errorFolderFullPath+",\nand after this program finishes you can manually correct it.\n \nIf you select 'No' the program will attempt to process the image normally."); // ask user density that they screened in	a = newArray("Yes","No");	Dialog.addChoice("", a, 0); // dropdown box, set initial choice to 1st element in array (1536)	Dialog.show();	answer = Dialog.getChoice();	if(answer == "No"){		close();		if(!showDebug){setBatchMode(true);}		open(currentFullPath+currentFile);		checkIfStack(); // checks to see if image is a stack, if it is this function will flatten it		convertToBlackWhite(0);		run("Set Scale...", "unit=");		return "true";	}	moveImage(currentFullPath, errorFolderFullPath, currentFile, 0, 0, 0, 0, 0, "true");	result= "Plate: "+currentFile+" could not be processed because of artifacts on the plate or a thresholding issue (threshold issues usually occur in image captured with uneven lighting).\n\n";	return result;}// function : close_window// input:// windowTitle -> title of window to close// purpose:// closes the window, if it is open, with a title == windowTitlefunction close_window(windowTitle){	if(isOpen(windowTitle)){ // check if window is open		selectWindow(windowTitle); // select window		run("Close"); // could use 'close();' but that would not close result or log windows	}}// function : collect_garbage// input:// wair_var -> time to wait between calls to gc, in milliseconds// purpose:// Run garbage collector. // Calling the gc method suggests that the Java Virtual Machine expend effort toward recycling unused objects in order// to make the memory they currently occupy available for quick reuse// calling it multiple times with a wait inbetween seems to increase the amount of memory released, although this// has not been extensively tested.function collect_garbage(wait_var){	call("java.lang.System.gc");	call("java.lang.System.gc"); // run garbage collector	call("java.lang.System.gc"); // run garbage collector	call("java.lang.System.gc"); // run garbage collector	call("java.lang.System.gc"); // run garbage collector	wait(wait_var);	call("java.lang.System.gc"); // run garbage collector	call("java.lang.System.gc"); // run garbage collector	call("java.lang.System.gc"); // run garbage collector	call("java.lang.System.gc"); // run garbage collector	call("java.lang.System.gc"); // run garbage collector}// function convertToBlackWhite// input:// despeckle -> if this == 1 then a despeckle filter will be applied after the threshold filter// purpose:// applies a threshold filter to image.// accepts 1 argument, despeckle. If it == 1, then after thresholding the image the ImageJ// Despeckle command is envoked// does not return any variablesfunction convertToBlackWhite(despeckle){	run("8-bit");	run("Out");	thresholdImage();	if(despeckle==1){		//run("Despeckle");		run("Despeckle");	}}// function : createProgressBar// input:// windowTitle -> title of progress bar window to be created// purpose:// creates a progress bar image with the given title (windowTitle). Nothing is returnedfunction createProgressBar(windowTitle){	saveSettings(); // save current settings	if(!showDebug){setBatchMode(false);}  // set batch mode to false so that the image we are about to create is displayed	newImage(windowTitle, "RGB", 400, 30, 1); // create the new image with the appropriate title	setFont("Serif", 18, "bold"); 	setJustification("center");	setColor(0, 0, 0); // black	drawString("0%", 200, 25); // type "0%" in the image	if(!showDebug){setBatchMode(true);} // set batch mode back to true	restoreSettings; // restore settings}// function : determineRowsAndColsProfile// input:// blackValue -> value of black (0 or 255)// purpose:// Determines the number of rows and columns of plates in current image. This assumes that // plates are distributed in a grid like fashion in the image, that there is a small amount// of space separating plates, and that anything that is not a plate (ie background, space between plates)// is black.function determineRowsAndColsProfile(blackValue){	run("Select All");	threshold = 50;	dipCountThreshold=30;	adjust = 0;	if(blackValue == 255){threshold = 255 - threshold; adjust=threshold;}	setKeyDown("alt"); // Set alt key down for vertical profiles	profile=getProfile(); // get verticle profile	setKeyDown("none"); //  reverse setKeyDown command	rowData=determineNumberOfDips(profile, threshold, blackValue);	profile=getProfile(); // get horizontal profile	colData=determineNumberOfDips(profile, threshold, blackValue);	if(showDebug){showMessageWithCancel("numberOfColumns = "+colData[0]+"\nmean column dip score = "+colData[1]+"\nNot in dip mean = "+colData[2]+"\n\nnumberOfRows = "+rowData[0]+"\nMean row dip score = "+rowData[1]+"\nNot in dip mean = "+rowData[2]);}	results=newArray(4);	results[0]=rowData[0];	results[1]=colData[0];	results[2]=(rowData[1]+colData[1])/2;	results[3]=(rowData[2]+colData[2])/2;	return results;}function determineNumberOfDips(profile, threshold, blackValue){	numberOfDips=1;	inDip = false;	inDipCounter=0;	meanDipValue = 0;	currentDipSum = 0;	notInDipSum=0;	notInDipCount=0;	if(showDebug){showMessageWithCancel("threshold = "+threshold+"\nblackValue = "+blackValue);}	for(i=0;i<profile.length;i++){		score = abs(profile[i] - blackValue);		if(score <= threshold){			if(inDip){inDipCounter+=1; currentDipSum += score;}			else{inDip = true; inDipCounter=1;currentDipSum=score;}		}		else{			if(inDip && inDipCounter > dipCountThreshold){	numberOfDips+=1; meanDipValue+=(currentDipSum/inDipCounter);	}			inDip=false;			inDipCounter = 0;			notInDipSum += score;			notInDipCount++;		}	}	if(numberOfDips > 0){meanDipValue = meanDipValue / numberOfDips;}	else{meanDipValue = -1;}	results=newArray(3);	results[0]=numberOfDips;	results[1]=meanDipValue;	results[2]=(notInDipSum/notInDipCount);	return results;}// function : determineRowsAndCols// input:// height,width -> height and width of image// blackValue -> value of black (0 or 255)// purpose:// Determines the number of rows and columns of plates in current image. This assumes that // plates are distributed in a grid like fashion in the image, that there is a small amount// of space separating plates, and that anything that is not a plate (ie background, space between plates)// is black.function determineRowsAndCols(height,width,blackValue){	rowCount=0;	pos=15;	temp1=pos;	while(pos<height){ // looking in y direction		temp=findEdge(0,(width/2),pos,pos,30,"false","white",blackValue, height, 200); // looking for white, ie a plate		// looking for black i.e. the space between plates		if(temp!=pos){temp1=findEdge(0,(width/2),temp,temp,30,"false", "black",blackValue, height,60);}		if(temp1==temp){pos=height;}		else{pos=temp1;}		if(showDebug){showMessageWithCancel("pos="+pos+", temp="+temp+", temp1="+temp1+"\nrow count = "+rowCount);}		rowCount++;	}	run("Appearance...", "  menu=0");	colCount=0;	if(showDebug){showMessageWithCancel("r="+rowCount+", c="+colCount);}	pos=15;	temp1=pos;	while(pos<width){ // looking in x direction		temp=findEdge(pos,pos,0,(height/2),30,"true", "white",blackValue, width, 200);		if(temp!=pos){temp1=findEdge(temp,temp,0,(height/2),30,"true", "black",blackValue, width, 60);}		if(temp1==temp){pos=width;}		else{pos=temp1;}		if(showDebug){showMessageWithCancel("pos="+pos+", temp="+temp+", temp1="+temp1+"\ncol count = "+colCount);}		colCount++;	}	run("Appearance...", "  menu=0");	if(showDebug){showMessageWithCancel("r="+rowCount+", c="+colCount);}	results=newArray(2);	results[0]=rowCount;	results[1]=colCount;	return results;}// function : dialogSetup// inputs:// condition_ids -> array containing all condition ids found in scan filenames// purpose:// get information from user about plates they are about to analyzefunction dialogSetup(condition_ids){	Dialog.create("Screen Information"); // create dialog to retreive user input	Dialog.addMessage("Fine-crop Mode:");	a = newArray("Automatic", "Manual");	Dialog.addChoice("\t", a, "Automatic"); // dropdown box, set initial choice to 1st element in array 'Automatic'	a = newArray("Standard", "Summation", "Background Subtracted");	Dialog.addMessage("Colony measurement method:");	Dialog.addChoice("\t", a, "Standard"); // dropdown box, set initial choice to 1st element in array Standard	d = newArray("2304","1536","384", "96");	Dialog.addMessage("Plate Density:");	Dialog.addChoice("\t", d, "1536"); // dropdown box, set initial choice to 1st element in array (1536)	Dialog.addMessage("File name to save measurements to:");	Dialog.addString("\t", "colonyAreas"); // default log file name to colonyAreaMeasurements	Dialog.addMessage("\n---------------------------------------------\n");	a = newArray("Standard", "Debug");	Dialog.addMessage("Running Mode:");	Dialog.addChoice("\t", a, "Standard"); // dropdown box, set initial choice to 1st element in array 	// display conditions to user that were found in the scan file names (if there are any)	// if there are more then 5 conditinos display them on multiple pages...	start=0;	end=0;	if(lengthOf(condition_ids)>=1){ 		condition_labels=newArray(condition_ids.length);		end=minOf( (start+5), condition_ids.length);		Dialog.addMessage("\n---------------------------------------------\n");		Dialog.addMessage("Please enter the condition(s) that corresponds\nto the following symbol(s) found in your file names.\n");		Dialog.addMessage("If incorrect symbol(s) are displayed below\nplease check the box labeled 'Incorrect Data' and then\nrename your images appropriately.");		Dialog.addMessage("BE SURE TO CLICK THE 'OK' BUTTON WHEN FINISHED.\nPRESSING THE ENTER KEY MAY RESULT IN AN ERROR.");		if(condition_ids.length>5){			numconditionDialogs=round( condition_ids.length/5+0.5);			Dialog.addMessage("\nFound a total of "+condition_ids.length+" conditions.\nDisplaying conditions "+(start+1)+" through "+end+" here.\nWill ask you about the others in subsequent dialogs.");		}		for (k=start; k<end; k++){Dialog.addString(condition_ids[k],"");}		Dialog.addCheckbox("Incorrect Data", false); // if for some reason incorrent data is presented, let the user stop progression		Dialog.show();		if(Dialog.getCheckbox()){exit("Please fix your image names and try again!");}	}	else{condition_ids = newArray("blankcondition"); condition_labels= newArray("blankcondition");Dialog.show();start=1;end=1;}	cropMode = Dialog.getChoice();	mode = Dialog.getChoice();	density=Dialog.getChoice();	logFileName=Dialog.getString();	showDebug=Dialog.getChoice();	while(density!="384" && density!="1536"  && density!="96" && density !="2304"){density=getString("Invalid density input (allowable values are 96, 384, 1536 and 2304).\nWhat is your density?","1536");}	if(showDebug == 'Standard'){showDebug=false;}	else{showDebug=true;}	// get condition labels entered thus far	for (k=start; k<end; k++){		if(condition_ids[k]!="blankcondition"){			condition_labels[k] = Dialog.getString();		}	}		start=end;	while(start<lengthOf(condition_ids)){		end=minOf( (start+5), condition_ids.length);		Dialog.create("Sub-Conditions"); // create dialog to retreive user input		Dialog.addMessage("Please enter the condition that corresponds\nto the following symbol(s) found in your file names.\n");		Dialog.addMessage("If incorrect symbols are displayed below\nplease check the box labeled 'Incorrect Data' and then\nrename your images appropriately.");		Dialog.addMessage("BE SURE TO CLICK THE 'OK' BUTTON WHEN FINISHED.\nPRESSING THE ENTER KEY MAY RESULT IN AN ERROR.");		if(condition_ids.length>5){			numconditionDialogs=round( condition_ids.length/5+0.5);			Dialog.addMessage("\nFound a total of "+condition_ids.length+" condition(s).\nDisplaying condition(s) "+(start)+" through "+(end+1)+" here.\nWill ask you about the others in subsequent dialogs.");		}		for (k=start; k<end; k++){Dialog.addString(condition_ids[k],"");}		Dialog.addCheckbox("Incorrect Data", false); // if for some reason incorrent data is presented, let the user stop progression		Dialog.show();		if(Dialog.getCheckbox()){exit("Please fix your image names and try again!");}		for (k=start; k<end; k++){			if(condition_ids[k]!="blankcondition"){ 				condition_labels[k] = Dialog.getString(); 			}		}		start=end;	}	// ensure that a condition label has been entered for all condition_ids identified (or at least ensure that they were not left blank)	for (k=0; k<condition_labels.length; k++){		if(condition_ids[k]!="blankcondition"){ 			while(condition_labels[k]==0 || condition_labels[k]==''){ // if a field is left blank it gets assigned a zero value 				condition_labels[k]=getString("You have not entered a condition for the symbol '"+condition_ids[k]+"'.\nWhat should this condition be identified as?",""); 			}		}	}		// ensure user has not entered illegal characters for log file name	flag=1;	while(flag){		if(lengthOf(logFileName)>0){flag=0;}		for(i=0;i<illegalLogFileNameChars.length;i++){			if(indexOf(logFileName, illegalLogFileNameChars[i])>0){flag=1;}		}		if(flag){			Dialog.create("Please enter a log file name");			Dialog.addMessage("ERROR!!!!!\nThe log file name you entered contained an illegal character.\nIllegal characters include: [, ], /, \\, ?, <, >, :, \", |, .");			Dialog.addMessage("Please enter a name to save your log file as:\t");			Dialog.addString("\tName: ", "log");			Dialog.show();			logFileName=Dialog.getString();		}	}			// based on density assign number of rows and colonies, reassign density as string	if(density=="1536"){density=1536;rows=32;cols=48;}	else if(density=="384"){density=384;rows=16;cols=24;}	else if(density=="96"){density=96;rows=8;cols=12;}	else if(density == "2304"){density=2304; rows=48;cols=48;}	else{exit("Invalid Density");}	results=newArray(8);	results[0]=mode;	results[1]=density;	results[2]=logFileName;	results[3]=rows;	results[4]=cols;	// have to convert array into string because you cannot return an array fo arrays	labels='';	for(i=0;i<condition_labels.length;i++){		condition_labels[i]=replace(condition_labels[i], "\t", " ");		if(labels==''){labels=condition_labels[i];}		else{labels=labels+"\t"+condition_labels[i];} // the use of \t here is arbitrary	}	results[5]=labels;	results[6]=showDebug;	results[7]=cropMode;	return results;}// function : drawAndMeasureSelectionLine// inputs:// x,y -> start coordinates of selection line// x2,y2 -> end coordinates of selection line// returns:// mean value of selection line// purpose:// draws a selection line from x,y to x2,y2, measures and returns the mean of the// line function drawAndMeasureSelectionLine(x,y,x2,y2){	makeLine(x, y, x2, y2);	run("Measure");	mean=getResult("Mean");	return mean;}// function : eDistance// inputs:// x1,y1 -> one coordinate// x2,y2 -> another coordinate// returns:// Euclidian distance between 2 points// purpose:// calculates euclidean distance between 2 cartesian coordinatesfunction eDistance(x1,y1,x2,y2){	return sqrt( (pow((x1-x2),2)+pow((y1-y2),2)));}// function : findAveDistance// inputs:// centroids -> an array containing a subset indicies from the x and y arrays. These are the centroids we are interesed in finding the aveage distance for// x,y -> x and y centroid coorindates of a super-set of particles// w -> width image (used as a large value)// items -> number of particles// returns:// the average calculated distance between particles// purpose:// this function will look at the particles indicated within the centroids array and return the averages Euclidean distance// between adjacent particles (based on centroid cooridinates)function findAveDistance(centroids, x, y, w, items){	refIndex=0;	distance=0;	minDistance=w;	aDistance=0;	for(ii=0;ii<items;ii++){		refIndex=centroids[ii];		for(jj=0;jj<items;jj++){			if(jj!=ii){				distance=eDistance( x[refIndex] , y[refIndex],x[centroids[jj]],y[centroids[jj]]);				if(distance<minDistance){minDistance=distance;}			}		}		aDistance+=minDistance;	}	//if(showDebug){showMessageWithCancel("ok","w="+w+"\naDistance="+aDistance+"\nitems="+items);}	return (aDistance/items);}// function : findBorder// inputs:// x1,y1,w,h = coordinates for initial rectangular selection// tWidth and tHeight = width and height of image// rows and cols = number of rows and columns that make up the grid of colonies// colValue -> value of a particle (0 or 255)// returns:// x (row) or y (column) value of outter colony border// purpose:// finds the outer edge of colony growth. Does this by drawing a rectangular selection centered over a row or // column of colonies. The imageJ function Analyze Particles is then used, with a fairly strict circularity constraint,// to determine the number of circular particles within the section. The number of particles within this initial selection// box serve as the "base" number of particles. The selection box is then moved towards the edge of the image by a distance// equivalent to a row (or column) or colonies, at each step having the particles within it analyzed. If fewer particles then// rFloor or more then rCeiling with the strict circularity constraint are found within the selection box the we can assume we are// outside the edge of colony borders. function findBorder(x1,y1,w,h,tWidth,tHeight,rows,cols,colValue){	// figure out border we are trying to find	iterator=1;	if (h>w){ // trying to find left or right border		direction="l_r";		if(x1 < (tWidth/2)){iterator=-1;} // moving to the left	}	else{		direction="t_b"; // trying to find top or bottom border		if(y1 < (tHeight/2)){iterator=-1;} // moving up	}		// set of base measurements	makeRectangle(x1, y1, w, h);	if(showDebug){showMessageWithCancel("x1 = "+x1+"\ny1 ="+y1+"\nw = "+w+"\nh ="+h+"\ndirection = "+direction+"\niterator = "+iterator+"\ntWidth = "+tWidth);}	run("Analyze Particles...", "size="+sizeCutoff+"-Infinity circularity=0.85-1.00 show=Nothing exclude clear");	baseTotalParticles=nResults;	if(baseTotalParticles==0){return -1;}	totalColonies=baseTotalParticles;	rFloor = baseTotalParticles*0.10;	rCeiling = baseTotalParticles*4;	if(showDebug){showMessageWithCancel("Base Particles="+totalColonies+"\nx1 = "+x1+"\ny1 = "+y1+"\nw = "+w+"\nh = "+h+"\nrFloor = "+rFloor);}	counter=0;	// begin moving rectangle till no longer over colonies	while(totalColonies>rFloor && totalColonies<rCeiling && counter < 40){		if(direction=="t_b"){y1=y1+(h*iterator);}		else{x1=x1+(w*iterator);}		makeRectangle(x1, y1, w, h);		run("Analyze Particles...", "size="+sizeCutoff+"-Infinity circularity=0.85-1.00 show=Nothing clear");		totalColonies=nResults;		run("Analyze Particles...", "size="+sizeCutoff+"-Infinity circularity=0.0-1.00 show=Nothing clear");		totalParticles=nResults;		noise = totalParticles / totalColonies;		if(noise > 3){totalColonies=0;}		if(showDebug){showMessageWithCancel("Colonies = "+totalColonies+"\n"+"Particles = "+totalParticles+"\nNoise = "+noise);}				counter++;	}	if(counter >= 40){return -1;}	else{		if(direction=="t_b"){border = checkIfBorderCentered(x1,(y1-(h*iterator)),w,h,direction,rows,cols,iterator,colValue);}		else{border = checkIfBorderCentered((x1-(w*iterator)),y1,w,h,direction,rows,cols,iterator,colValue);}		return border;	}}// function : findEdge// inputs:// startX, endX, startY, endY -> coordinates for selection line to start at// iterator -> integer indicating how much to move selection line at each step// isThisLeftRight -> if we are trying to find the left or right edge this should == "true"// black_or_white -> color of the space we are currently in. Should be == black or white. If == "black" assume we are searching for white edge, conversely if it == "white" // blackVal -> black value (0 or 255)// limit -> should be == to width (left / right edge) or height (top / bottom edge) of image, basically ensures we stay within the bounds of the image// thresholdValue -> value to indicate that we have reached an edge. Lower = more sensitive to changes // returns:// position of edge (x or y value depending on value of isThisLeftRight)// purpose:// finds black or white edge of image depending on parameters passed to it.function findEdge(startX, endX, startY, endY, iterator, isThisLeftRight, black_or_white, blackVal, limit,threshold){	count=0;	origX=startX;	origY=startY;	flag="false";	if(black_or_white=="white"){ // triming white border		if(blackVal < 60){ // black value is < 60, meaning it is 0 and then white value is 255...			flag="true";			if(threshold > 0){threshold*=-1;}			threshold= -255-threshold;		}	}	else{		if(blackVal > 60){			flag="true";			if(threshold > 0){threshold*=-1;}		}	}	mean = threshold-5;	if(showDebug){showMessageWithCancel("black_or_white = "+black_or_white+"\nflag = "+flag+"\nthreshold = "+threshold+"\nmean = "+mean+"\nblackVal = "+blackVal+"\nstartX = "+startX+"\nstartY = "+startY+"\nlimit = "+limit);}		while(mean<=threshold  && count<150){		if(isThisLeftRight=="true"){startX+=iterator;endX=startX; if(startX > limit || startX<0){count=150;}}		else{startY+=iterator;endY=startY; if(startY > limit  || startY<0){count=150;}}		mean = drawAndMeasureSelectionLine(startX, startY, endX, endY);		if(flag=="true"){mean=mean*-1;}		//if(showDebug){showMessageWithCancel("mean = "+mean);}		count++;	}	if(showDebug){showMessageWithCancel("mean = "+mean+"\nthresh ="+threshold+"\ncount= "+count);}	result=0;	if(count>=149){		if(isThisLeftRight=="true"){result=origX;}		else{result=origY;}	}	else{		if(isThisLeftRight=="true"){result=startX;}		else{result=startY;}	}	return result;}// function : getArrayAverage// input:// array --> array to be averaged// returns:// average value of items in an array// purpose:// returns the average of all of the values within an arrayfunction getArrayAverage(array){	sum=0;	for(i=0;i<array.length;i++){		sum+=array[i];	}	return sum/array.length;}// function : getBlackValue// returns:// black value// purpose:// determine the value for black in currently open image (0 or 255) and return itfunction getBlackValue(){	// determine if value of black is 0 or 255	setLineWidth(1);	setColor("black");	drawLine(0, 0, 1, 1);	makeRectangle(0, 0, 1, 1);	run("Measure");	return getResult("Mean");}// function : getColonyValue// inputs:// shouldSelectAll -> if this == 1 the entire area of the image will be selected prior to analyzing// returns:// color value of particle// purpose:// determine the color value of a particle (0 or 255 i thinks)function getColonyValue(shouldSelectAll){	if(shouldSelectAll==1){run("Select All");}	run("Analyze Particles...", "size=20-Infinity circularity=0.80-1.00 show=Nothing exclude clear");	value=0;	for (i=0; i<nResults; i++) {value = value+getResult("Mean",i);}	if(value>0){value=value/nResults;}	run("Clear Results");	return value;	}// function : identifyconditions// inputs:// files -> array containing file names// home_dir -> parent directory where this all started// returns:// array containing condition ids// purpose:// identify and return all conditions id within the image file names in the files array sent to this functionfunction identifyconditions(files, home_dir){	conditions="";	errorLog="";	numconditions=0;	counter=0; // keeps track of how many images we have checked...	for (i=0; i<files.length; i++){		if(!File.isDirectory(home_dir+files[i])){ // if file actually exists			file=split(files[i],"."); // split file names based on comment			/* really do not need to verify this...			if(file.length > 2){ // check to ensure only 1 period entered?				errorLog=errorLog+"Original Scan : "+files[i]+" contains more then 1 period and therefore cannot be properly process\nThe only period present in the file name permitted is the one that indicates the file extension.\n\n";				if(!File.isDirectory(home_dir+"rough_crop_errors/")) // will store error scans					File.makeDirectory(home_dir+"rough_crop_errors");					// need to say 'fileMoved =' because without it File.rename will print the result of the rename				// to the screen (1 for success, 0, i suppose, if error)				fileMoved=File.rename(home_dir+"/"+files[i], home_dir+"rough_crop_errors/"+files[i]);			}*/			//else{						// keeping this if statement in case it is decided in the future to re-introduce the above, commented-out code (in which case it will have to be change to an else statement			if(1){				lastIndex=file.length-1;				// check to see if file is an image file. 				if(file[lastIndex]=="tiff" || file[lastIndex]=="tif" || file[lastIndex]=="gif" || file[lastIndex]=="jpg" || file[lastIndex]=="png" || file[lastIndex]=="jpeg" || file[lastIndex]=="bmp"){					file=split(file[0],",");  // split filemane base on commas					counter++;					// start at 1 since 1st index refers to query name					for (j=1; j<file.length; j++){						file[j]=replace(file[j], "^ *", ""); // replace space characters at begining of plate identifier						file[j]=replace(file[j], " *$", ""); // replace space characters at end of plate identifier						//print ("="+file[j]+"=");						last_index=lengthOf(file[j]);						last_index--; // need to subtract 1 since the above lengthOf function returns the lenfth of the string but we want the position # (index) of the last character of the string, and indices start at 0 (as opposed to 1)						condition="";						while(last_index > 0){							character=substring(file[j], last_index, (last_index+1));							last_index--;							// no  \ / : ? " < > | allowed in windows file names so we won't consider as condition							// identifiers.  Will use +, ~, ^, #, @							if(character=="+" || character=="~" || character=="^" || character=="#" || character=="@"){condition=character+condition;}							// break out of loop is no sub-condition found							else{last_index=-1;}						}						// if any sub-conditions found, modify condition_ids and conditions appropriately						if(condition!=""){							exists="false";							condition_ids=split(conditions,"?");							for (k=0; k<condition_ids.length; k++)								if(condition_ids[k]==condition){exists="true";}							if(exists=="false"){								conditions=conditions+"?"+condition; // use "?" as a delimiter since is cannot be used to identify conditions								numconditions++;							}						}					}				}			}		}	}	if(numconditions>0){condition_ids=split(conditions,"?");}	else{condition_ids='';}	return condition_ids;}// function : measureColonies// inputs:// home_dir -> parent directory where this all started// rows, cols -> number of rows and columns that make up the ordered grid of colonies// density -> density screened in (eg 384 or 1536)// mode -> method which user chose to measure colony areas// logFileName -> user defined file name to save colony area measurements to// purpose:// measure colony area measurements in the "fine_crops/" and maybe "fine_crop_errors/" directories based on the mode the // user had chosen. All images in fine_crops are processed first. Follwoing this images in "fine_crop_errors" may have their// colony areas measured IFF the image currently being examined in "fine_crop_errors/" has a width and height measurement similar // to the average height and width measurements calculated for images in the "fine_crops/" directory.function measureColonies(home_dir, rows, cols, density, mode, logFileName){	run("Clear Results");	print("\\Clear"); // clear log file 	// directories = dirs to look for cropped images in...	directories=newArray("fine_crops/","fine_crop_errors/");		differences="";	//if(showDebug){showMessageWithCancel("colony size measurements start now");}	aveWidth=0;	aveHeight=0;	numPlates=0;	errorLog="";	// if logFileName already exists in home directory, add an additional charater to it so that	// the log file we are about to generate does not overwrite it	i=0;	temp=logFileName;	while(File.exists(home_dir+logFileName+".txt")==1){ // if log file already exists change name to prevent overwriting it		logFileName=temp;		logFileName=logFileName+"-"+alpha[i++];	}		widthCeiling=0;	heightCeiling=0;	widthFloor=0;	heightFloor=0;	save_dir=home_dir+"measurements_passed/";	error_dir=home_dir+"measurement_errors/";	plateCounter=0;	for(dd=0;dd<directories.length;dd++){		current_dir=home_dir+directories[dd];		createProgressBar("Colony Measurement Progress ("+directories[dd]+")");		if(File.isDirectory(current_dir)){			files=getFileList(current_dir);			for (xx=0; xx<files.length; xx++){				file=split(files[xx],".");				extension=file[(file.length-1)]; 				if(!File.isDirectory(current_dir+files[xx]) && (extension=="tiff" || extension=="tif" || extension=="gif" || extension=="jpeg" || extension=="bmp" || extension=="jpg" || extension=="png")){					open(current_dir+files[xx]);					plateCounter+=1;					checkIfStack(); // checks to see if image is a stack, if it is this function will flatten it					if(mode != "Background Subtracted"){convertToBlackWhite(0);} // in itergrated density mode we do not threshold the image					else{run("8-bit"); } // convert to grayscale					run("Set Scale...", "unit="); // remove scale					width = getWidth();					height = getHeight();					//if(showDebug){showMessageWithCancel(width+" --> "+widthCeiling+" --> "+widthFloor+"\n"+height+" --> "+heightCeiling+" --> "+heightFloor);}					good_looking_plate=1;					//if(showDebug){showMessageWithCancel(directories[dd]);}					if(directories[dd]=="fine_crops/"){						aveWidth+=width;						aveHeight+=height;						numPlates++;						//print("ok\n");					}					else{ //  "fine_crop_errors/" check to make sure these images are within the width and height constraints defined by the images already analyzed from the "fine_crops/" folder						if(!(width <= widthCeiling && width >= widthFloor && height >= heightFloor && height <= heightCeiling)){							//if(!File.isDirectory(original_dir+"fine_crops/measurement_errors/"))							//	File.makeDirectory(original_dir+"fine_crops/measurement_errors/");							//if(showDebug){showMessageWithCancel("w = "+width+"\nwc = " + widthCeiling + "\nwf = "+widthFloor+"\nh = "+height+"\nhc = " + heightCeiling + "\nhf = "+heightFloor);}							good_looking_plate=0;							//errorLog=errorLog+"Plate: "+files[xx]+" did not have its colonies measured.\nThis is most likely due to a cropping error.\n\n";							//saveAs("Tiff", original_dir+"fine_crops/measurement_errors/"+files[xx]);							///deletion_result=File.delete(dir1+files[xx]);							close();						}					}					if(good_looking_plate){ // if good_looking_plate != 0 						// grid width and height...these could also be refered to as cell width and height						grid_width=width/cols;						grid_height=height/rows;						//if(showDebug){showMessageWithCancel("Grid Width = "+grid_width+"\nGrid Height = "+grid_height+"\nRow = "+rows+", Cols = "+cols);}						if(mode == "Standard"){							errorLog=errorLog+measureStandard(density, rows, cols, grid_width, grid_height, current_dir, home_dir, save_dir, error_dir, files[xx],errorLog);						}						else if(mode == "Summation"){errorLog=errorLog+measureSummation(density, rows, cols, grid_width, grid_height, current_dir, home_dir, save_dir, error_dir, files[xx],errorLog);}						// else mode == "Background Subtracted"						else{measureBackgroundSubtracted(density, rows, cols, grid_width, grid_height, width, height, current_dir, home_dir, save_dir, files[xx]);}						close_window(files[xx]); // should already be closed, but check anyways					}				}				changeProgress("Colony Measurement Progress ("+directories[dd]+")",xx, files.length, 176, 196,222); // light steel blue			}			aveWidth=aveWidth/numPlates;			aveHeight=aveHeight/numPlates;			//if(showDebug){showMessageWithCancel(aveWidth+"\n"+aveHeight);}			widthCeiling=aveWidth*1.01;			heightCeiling=aveHeight*1.01;			widthFloor=aveWidth*0.99;			heightFloor=aveHeight*0.99;		}		close_window("Colony Measurement Progress ("+directories[dd]+")");	}		if(plateCounter == 0){		showMessage("No fine cropped images found! Please consult the CM Engine instruction manual to ensure you have place images in the proper directory and ensure that your images are in a format that ImageJ can recognize.\n\n\nThis error may also occur if all of your images failed validation.");		exit;	}	selectWindow("Log");	saveAs("txt", home_dir+logFileName);	finalMessage="Analysis Completed\n";	print("\\Clear"); // clear log file	if(errorLog!=""){		if(!File.isDirectory(home_dir+"measurement_errors/")){File.makeDirectory(home_dir+"measurement_errors/");}		print (errorLog);		selectWindow("Log");		saveAs("txt", home_dir+"measurement_errors/error_notes"); 		print("\\Clear"); // clear log file		finalMessage=finalMessage+"\nSee the error directory(s) for images that were not analyzed completely.  See error_notes.txt in the same directory(s) for an explanation of why errors occurred.";	}		clearedLog='';	// assume the fine crop error directory == directories[1]. Check to see if it exists	if(File.isDirectory(home_dir+directories[1])){		// get the file list in the fine crop error directory		files=getFileList(home_dir+directories[1]);		// get the file list in the fine crop error Orignals directory		if(File.isDirectory(home_dir+directories[1]+"originals/")){			ofiles=getFileList(home_dir+directories[1]+"originals/");			// compare the images in both directories. All images that have fine crop errors should be in the originals directory			// but if a so-called fine crop error has similar dimensions to successfull fine crops then it may have had its			// colony areas measure and may no longer be in the fine_crop_errors directory. 			// The goal here is to create a list of the images that did not pass fine crop validation but had their colonies measured			// successfully			for (xx=0; xx<ofiles.length; xx++){				file=split(ofiles[xx],".");				found="true";				extension=file[(file.length-1)]; 				if(!File.isDirectory(home_dir+directories[1]+ofiles[xx]) && (extension=="tiff" || extension=="tif" || extension=="gif" || extension=="jpeg" || extension=="bmp" || extension=="jpg" || extension=="png")){					found="false";					for(yy=0;yy<files.length;yy++){						if(files[yy] == ofiles[xx]){ // if the file exists in both directories							found="true";						}					}				}				if(found=="false"){ // image does not exist in both directories, must of had its colonies measured successfully					// could also add another check here to determine if the image not found exists in the measurements passed or measurement error directories					clearedLog=clearedLog+ofiles[xx]+" was in the 'fine_crop_errors' directory but had its colonies measured becuase on second inspection it seems like it was cropped properly.\nAssuming its colony areas were measured properly, it has been moved the the 'measurements_passed' directory and its colony areas were appended to the log file. If its colony areas were not measured properly it have been moved to the 'measurement_errors' directory.\n\n";				}			}		}	}	files=getFileList(home_dir+directories[1]);	if(clearedLog !=""){		print (clearedLog);		selectWindow("Log");		saveAs("txt", home_dir+"passing_notes");		run("Clear Results");	}	close_window("Results");	close_window("Log");  showMessage(finalMessage+"\nNote that if you have created more then one log file they should be merged into one 'master' log file before moving on to the next step of analysis.");}// function : measureBackgroundSubtracted // inputs:// density -> density screened in (eg 384 or 1536)// rows, cols -> number of rows and columns that make up the ordered grid of colonies// grid_width, grid_height -> width and hieght of a cell within the grid of colonies// width, height -> width and height of image// current_dir -> directory where current image resides// home_dir -> parent directory where this all started// save_dir -> where to move successfully processed images// currentFile -> file name of current image being processed // purpose:// measure area of colonies present on plate using  an algorithm that attempts ti subtract the background from the measurement.// This mode divides a image into a grid based on the number of rows and columnss of colonies present (which was previously determined, based on density )// and then assigns colony area based on the background substracted mean of each cell that comproses the grid.function measureBackgroundSubtracted(density, rows, cols, grid_width, grid_height, width, height, current_dir, home_dir, save_dir, currentFile){	close_window("Results");	run("Set Measurements...", "max min mean redirect=None decimal=6");	// to determine if the image should be inverted or not...	// make a duplicate of current image, threshold it then 'analyze particles'. Then invert it and 'analyze particles again.	// The one with more particles is the correct image to analyze.	selectWindow(currentFile); // select window	run("Duplicate...", "title=temp");	run("Threshold", "thresholded remaining black");	run("Convert to Mask", "calculate black");	run("Analyze Particles...", "size=50-1000 circularity=0.80-1.00 show=Nothing display clear");	totalParticles1=nResults;	selectWindow("temp"); // select window	run("Invert");	run("Analyze Particles...", "size=50-1000 circularity=0.80-1.00 show=Nothing display clear");	noInversion=false;	totalParticles2=nResults;	//showMessageWithCancel("Tp1 = "+ totalParticles1+"\ntp2= "+ totalParticles2);	close_window("temp");	selectWindow(currentFile); // select window	if(totalParticles1 > totalParticles2){	run("Invert");	noInversion=true;}	//showMessageWithCancel("inverting");		startX=newArray(cols);	endX=newArray(cols);	quarterW= grid_width/4;	halfW= grid_width/2;	bestFiti=0;	bestFitj=0;	xoffA=0;	xoffB=0;	count=0;		// draw vertical lines	while (count < cols) {		max=0;		for(i=xoffA+quarterW;i<(xoffA+grid_width-quarterW);i+=2){			for(j= xoffB +quarterW;j<(xoffB +grid_width-quarterW);j+=2){				makeLine(i, 0, j, height);				run("Measure");				mean=getResult("Mean");				//showMessageWithCancel("mean = "+mean);				if(mean>max){max=mean; bestFiti=i;bestFitj =j;}			}		}		startX[count]=bestFiti;		endX[count]=bestFitj;		count+=1;		xoffB = bestFitj+halfW;		xoffA = bestFiti+halfW;	}	bestFiti=0;	bestFitj=0;	xoffA=0;	xoffB=0;	count=0;	startY=newArray(rows);	endY=newArray(rows);	quarterH= grid_height/4;	halfH= grid_height/2;		// draw horizontal lines	while (count < rows){		max=0;		for(i= xoffA +quarterH;i<(xoffA+grid_height-quarterH);i+=2){			for(j= xoffB +quarterH;j<(xoffB +grid_height-quarterH);j+=2){				makeLine(0, i, width, j);				run("Measure");				mean=getResult("Mean");				//showMessageWithCancel("mean = "+mean);				if(mean>max){max=mean; bestFiti =i;bestFitj =j;}			}		}		startY[count]=bestFiti;		endY[count]=bestFitj;		count+=1;		xoffB = bestFitj+halfH;		xoffA = bestFiti+halfH;		max=0;	}				runCount=0;	invertCounter=newArray(2);	tempSizeResults=newArray(density);	while(runCount<2){		count=0;		lastX=0;		lastY=0;		size_results=newArray(density);		invertCounter[runCount]=0;				for(i=0;i<cols;i++){			x1=endX[i];			x2=startX[i];			y1=0;			y2=height;			for(j=0;j<rows;j++){				x3=0;				x4=width;				y3=height-startY[j];				y4=height-endY[j];				d = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);				if (d == 0){					x = grid_width*i;					y = grid_height*j;				}				else{					x = ((x3-x4)*(x1*y2-y1*x2)-(x1-x2)*(x3*y4-y3*x4))/d;					x-=halfW;					y = height-((y3-y4)*(x1*y2-y1*x2)-(y1-y2)*(x3*y4-y3*x4))/d;							y-=halfH;				}				g_width=grid_width;				g_height=grid_height;				if( (y+g_height) >= height){y = height-g_height-1;}				makeRectangle(x, y, g_width, g_height);				// if(showDebug && (i+1)*32+j+1 > 220){	showMessageWithCancel("initial selection");	}				centerSelectionOverColony(width, height, i,j);				getSelectionBounds(x, y, g_width, g_height);				backgroundX=x+2;backgroundY=y+2;g_height-=2;g_width-=2; // ensure pixels are in interior of selection				if(backgroundX<0){backgroundX=1;}				else if(backgroundX>width){backgroundX=width-1;}				if(backgroundY<0){backgroundY=1;}				else if(backgroundY>height){backgroundY=height-1;}				bottom = backgroundY+g_height;				if(bottom >= height){bottom=height-1;}				right = backgroundX+g_width;				if(right >= width){right=width-1;}				background=calculateBackground(backgroundX, backgroundY, right, bottom);				run("Measure");				//if(showDebug){showMessageWithCancel("backgroundX = "+backgroundX+", backgroundY = "+backgroundY+", right ="+right+",bottom = "+bottom+"\nbackground = "+background+"\n90% of max = "+(getResult('Max')*0.9));}				// if background > 90% of the max value within this cell then perhaps we are 				if(background >=(getResult('Max')*0.9)){					invertCounter[runCount]+=1;					//run("Invert"); 					//background=calculateBackground(backgroundX, backgroundY, g_width, g_height);				}				run("Subtract...", "value="+background); // subtract out background			  run("Measure");				size_results[count]=getResult('Mean');				//if(showDebug && (i*48+j+1) > 0){showMessageWithCancel("SIZE = "+size_results[count]+"\ni = "+i+"\nj = "+j);}				run("Undo");// add background back in				count++;			}		}		//if(showDebug){showMessageWithCancel("done\ninvertCounter = "+invertCounter[runCount]+"\n\nrunCount = "+runCount);		}		// if invert counter > half the density of the plate then we probably should have inverted the image		if(invertCounter[runCount] > ((rows*cols)/2)){			// if after the inversion the invertCounter is greater then we probably did the measurements right the first time...			if(runCount > 0 && invertCounter[1] > invertCounter[0]){				size_results = tempSizeResults;			}			else{				close_window(currentFile);				open(current_dir+currentFile);				run("8-bit"); // convert to grayscale				if(noInversion){run("Select All");run("Invert");}				tempSizeResults = size_results;			}			runCount+=1; 		}		else{runCount = 1000;}	}	//showMessageWithCancel("done");	moveImage(current_dir, save_dir, currentFile, 0, 0, 0, 0, 0, "true");	selectWindow("Log");	print(currentFile);	printArray(size_results);	selectWindow("Log");	saveAs("txt", home_dir+logFileName); // save after each iteration in case program crashes	run("Select None");}// function : measureStandard // inputs:// density -> density screened in (eg 384 or 1536)// rows, cols -> number of rows and columns that make up the ordered grid of colonies// grid_width, grid_height -> width and hieght of a cell within the grid of colonies// current_dir -> directory where current image resides// home_dir -> parent directory where this all started// save_dir -> where to move successfully processed images// error_dir -> where to move unsuccessfully processed images// currentFile -> file name of current image being processed // errorLog -> log used to keep track of any error message we encounter// returns:// errorLog// purpose:// measure area of colonies present on plate using standard mode. This mode applies a threshold filter to the image and analyzes// all the particles in the image. It the divides a image into a grid based on the number of rows and cols of colonies present (which was // previously determined, based on density ) and then assigns colony area values to the largest of all particles within each cell of the grid.// This function also attempts to detect any artifacts / abnormalities on the plate and presents them to the user so that they may correct themfunction measureStandard(density, rows, cols, grid_width, grid_height, current_dir, home_dir, save_dir, error_dir, currentFile, errorLog){  // root folder is a full path, currentFolder and currentFiles are relative.	analyzeParticles(5,0.00,"");	if(showDebug){showMessageWithCancel("look at particles");}	// following array will hold the x and y coordinates of the centroid of all colonies and their sizes	x_centroids=newArray(nResults);	y_centroids=newArray(nResults);	sizes=newArray(nResults);	circularity=newArray(nResults);	//meanArea=getResult("Area",1541);	stepper = setStepper(density,cols);		//if(showDebug){showMessageWithCancel((density-nResults)+"\n"+stepper);}	// get centroid coordinates and sizes, stpre them in x_centroids and y_centroids	// also compute average colony area (areas > 25)	// also determine maximum size and circularity	average=0;	maxSize=0;	modColonies=0;	circOfMax=0;	for (i=0; i<nResults; i++) {		x_centroids[i]=getResult("X",i);		y_centroids[i]=getResult("Y",i);		sizes[i]=getResult("Area", i);		circularity[i]=getResult("Circ.", i);		if(sizes[i]>growthCutOff){			average+=sizes[i];			modColonies++;		}		if(sizes[i]>maxSize){			maxSize=sizes[i];			circOfMax= circularity[i];		}	}	goodPlate = "true";	// if the maxSize of a particle on a plate > (grid_width * grid_height) && circOfMax > 0.009	// then this plate may have a thresholding issue (note that this is a pretty crude way to detect this)	if(maxSize > (grid_width * grid_height) && circOfMax > 0.009 ){		goodPlate = checkThreshold(current_dir, error_dir, currentFile);		if(goodPlate != "true"){errorLog=errorLog+goodPlate;}	}		//if(showDebug){showMessageWithCancel(sizes[166]+"\n"+circularity[166]+"\n"+x_centroids[166]);}	// figure out average and standard deviation of colony sizes, this will help us determine	// out if there are blemishes on our plate as we iterate over it.  The plan will be to use	// the average particle size +/- the standard deviation as our floor and ceiling range values	// if a particle size does not fall within this range and it's circularity is below circLimit AND	// its size is greater then growthCutOff (circularity degrades as colonies get smaller), besides we are looking	// for smudges and blemishes on plates which must likely will be much larger then growthCutOff.....	if(goodPlate == "true"){		average=average/modColonies;		modAverage=0;		modColonies1=0;		modCutOff=average*deadCutoff; // deadCutoff = arbitrary (sounds better if I say "empirically determined')		stdev=0;		for(i=0;i<sizes.length;i++){			if(sizes[i] > modCutOff){				modAverage+=sizes[i];				modColonies1++;			}			if(sizes[i]>growthCutOff){stdev+=pow((sizes[i]-average),2);} // 25 = arbitrary (sounds better if I say "empirically determined')		}		stdev=sqrt( (stdev/(modColonies-1) ) );		modAverage=modAverage/modColonies1;		deadThreshold=modAverage*deadCutoff; // deadCutoff = arbitrary (sounds better if I say "empirically determined')		sizeCeiling=average+stdev;		sizeFloor=average-stdev;		superSizeCeiling = average+(stdev*2); // absolute ceiling, any colony greater then this will be subject to greater circularity stingency		superCircLimit=0.9;		if(showDebug){			showMessageWithCancel("floor = "+sizeFloor+"\nsize ceiling = "+sizeCeiling+"\nstd_dev = "+stdev+"\nmodCutOff = "+modCutOff+"\nStandard Deviation = "+stdev+"\nMod Average = "+modAverage+"\nDead Thresh = "+deadThreshold+"\nSize Ceiling = "+sizeCeiling+"\nSize Floor = "+sizeFloor+"\nsuperSizeCeiling = "+superSizeCeiling);			printResults(x_centroids, y_centroids, true);		}				// iterate over rows and columns, set x and y range where centroid should lie, iterate over x and y centroid arrays		// if centroid falls within range then add the corresponding colony size to the results array, if no centroid found		// to fall within range add 0 to results array.		// Once a size has been assigned to results array, increment assignments variable.  This will allow us to track how many 		// sizes were pushed into the results array.  If this number significantly differentiates from the length of the sizes array		// then we have an issue				startingK=0;		errorCount=1;		//sizeLimit=maxOf(average-stdev*3,average*0.1); // circularity degraded for smaller sized colonies, 		sizeLimit = deadThreshold; // 		errorIndices=newArray(density);		errorResultIndices=newArray(density);		startFromBeginning=false;		while(errorCount>0){			colonyNum=0;			assignments=0;			startingK=0;			lastK=0;			errorCount=0;			myCounter=0;			size_results=newArray(density);			circ_results=newArray(density);			for(i=0;i<rows;i++){				yCenFloor=i*grid_height;				yCenCeiling=yCenFloor+grid_height;				lastX_rightColonyEdge=0;				for(j=0;j<cols;j++){					showProgress( (colonyNum/density) );					index=i+j*rows;					size_results[index]=0;					circ_results[index]=0;					xCenFloor=j*grid_width;					if(xCenFloor < lastX_rightColonyEdge){xCenFloor=lastX_rightColonyEdge;}					lastX_rightColonyEdge=0;					xCenCeiling=xCenFloor+grid_width;					if(showDebug){						makeRectangle(xCenFloor, yCenFloor, (xCenCeiling-xCenFloor),  (yCenCeiling-yCenFloor));						showMessageWithCancel ("\n"+alpha[i]+""+(j+1)+"\nxCenFloor = "+xCenFloor+"\nxCenCeiling = "+xCenCeiling+"\nyCenFloor = "+yCenFloor+"\nyCenCeiling = "+yCenCeiling+"\nstartingK = "+startingK);					}					nextYCeiling=yCenCeiling+grid_height;					for(k=startingK; k < x_centroids.length; k++){						//if(showDebug){showMessageWithCancel("k = "+k+", x = "+x_centroids[k]+", y = "+y_centroids[k]+" --> Size = "+sizes[k]+", Circularity = "+circularity[k]);}						abnormal="false";						// check to see if particle is abnormal...						if((sizes[k] > sizeCeiling || sizes[k] < sizeFloor) && (circularity[k] < circLimit && sizes[k] > sizeLimit)){							abnormal="true";						}						// check to see if we can move on to next row...						if(y_centroids[k] > nextYCeiling && abnormal=="false"){							//if(showDebug){showMessageWithCancel ("y cen = "+y_centroids[k]+", next ceiling = "+nextYCeiling);}							k=x_centroids.length;																	}						else{							if(x_centroids[k] > xCenFloor && x_centroids[k] < xCenCeiling){ // check to see if centroid lies within x range								if(y_centroids[k] > yCenFloor && y_centroids[k] < yCenCeiling){ // check to see if centroid lies within y range									if(showDebug){										makeRectangle(xCenFloor, yCenFloor, (xCenCeiling-xCenFloor),  (yCenCeiling-yCenFloor));										showMessageWithCancel("PASSED -->\nx = "+x_centroids[k]+"\ny = "+y_centroids[k]+"\nSize = "+sizes[k]+"\nCircularity = "+circularity[k]+"\nk = "+k+"\nindex = "+index+"\nxCenFloor = "+xCenFloor+"\nxCenCeiling = "+xCenCeiling+"\nyCenFloor = "+yCenFloor+"\nyCenCeiling = "+yCenCeiling+"\nstartingK = "+startingK+"\nk="+k);									}									if(abnormal=="true"){ // check to see if size and circularity does not lie within size and circularity ranges										errorIndices[errorCount++]=k;										errorResultIndices[errorCount]=index;									}									else{										lastX_rightColonyEdge = x_centroids[k]+sqrt(sizes[k]/3.14)+2;										//showMessageWithCancel("lastX_rightColonyEdge = "+lastX_rightColonyEdge);										myCounter++;										lastK=k;										if(sizes[k] > size_results[index]){											size_results[index]=sizes[k];											circ_results[index]=circularity[k];											assignments++;										}									}								}							}						}					}					colonyNum++;				}				if(startFromBeginning){startingK=0;}				else{					startingK=lastK; // setting the starting K to the last k of the previous row should protect us from messing up since particles are ordered by y postion in ascending order					if(startingK<0){startingK=0;}				}			}			collect_garbage(50);			// iterate over errors (blemishes) check to see if a particle with a larger size go pushed into results array			// if so we can ignore that error			//if(showDebug){showMessageWithCancel("error Report","superSizeCeiling = "+superSizeCeiling+", sizeCeiling = "+sizeCeiling+", circLimit = "+circLimit+", sizeLimit = "+sizeLimit+"\nNumber of errors = "+errorCount);}			//if(showDebug){showMessageWithCancel("title","# of sizes="+(sizes.length)+"\nnumber of assignments="+assignments+"\nDifference: "+((sizes.length)-assignments)+"\nMy Counter = "+myCounter) ;}			for(e=0;e<errorCount;e++){				if(size_results[errorResultIndices[e]]>sizes[errorIndices[e]]){errorCount--;}			}						assignRatio = assignments / sizes.length;						if(errorCount > 0){				close_window(currentFile);				if(!showDebug){setBatchMode(false);} // runs up to 6 times faster				open(current_dir+currentFile);				checkIfStack(); // checks to see if image is a stack, if it is this function will flatten it				convertToBlackWhite(0);				run("Set Scale...", "unit=");				showErrors(errorIndices,y_centroids,x_centroids,circularity,sizes,errorCount);				thresholdImage();				//save(home_dir+files[xx]); // save any changes made				// run analyze particles again, as above...				run("Analyze Particles...", "size=5-Infinity circularity=0.00-1.00 show=Nothing clear");				x_centroids=newArray(nResults);y_centroids=newArray(nResults);				sizes=newArray(nResults);				circularity=newArray(nResults);				stepper = setStepper(density,cols);				for (i=0; i<nResults; i++) {					x_centroids[i]=getResult("X",i);y_centroids[i]=getResult("Y",i);					sizes[i]=getResult("Area", i);circularity[i]=getResult("Circ.", i);				}				close_window(currentFile);				if(!showDebug){setBatchMode(true);}				sizeLimit=maxSize+1; // setting size limit to maxSize+1 will prevent us from logging plate blemishes again				superCircLimit=0; // setting superCircLimit to 0 will prevent us from logging plate blemishes again			}						// if assign ratio < 0.95 (5%) then re-run the assingment algorithm, but this time always start k at 0. This will help to avoild a potential error caused when there are many blanks present on the page			if(assignRatio < 0.95 && !startFromBeginning){				errorCount=1; 				startFromBeginning=true;				if(showDebug){					showMessageWithCancel("Failed assignment test, will re-run particle assignment with k consistantly at 0.\n\nAssignments = "+assignments+"\nParticles on plate = "+sizes.length+"\nRatio = "+assignRatio);				}			}			collect_garbage(50);		}				if(showDebug){showMessageWithCancel("Assignments = "+assignments+"\nParticles on plate = "+sizes.length+"\nRatio = "+assignRatio);}				if(assignRatio >= 0.75 && assignRatio <= 1.0){			//if(showDebug){showMessageWithCancel(files[xx]+"\tGrowth Average = "+modAverage+"\tDeath Threshold = "+deadThreshold);}			moveImage(current_dir, save_dir, currentFile, 0, 0, 0, 0, 0, "true");			selectWindow("Log");			print(currentFile);			printResults(size_results, circ_results, false);			selectWindow("Log");			saveAs("txt", home_dir+logFileName);// save after each iteration in case program crashes		}		else{			differences=differences+currentFile+" - "+((sizes.length)-assignments)+"\n";			errorLog=errorLog+"Plate: "+currentFile+" did not have its colonies measured.\n";			errorLog=errorLog+"This is because the number of particles on the plate ("+(sizes.length)+") differs to much from the number of particles on the plate determined to be actually colonies ("+assignments+").\n";			errorLog=errorLog+"This difference is probably due to this plate containing stray marks or contamination.\n\n";			moveImage(current_dir, error_dir, currentFile, 0, 0, 0, 0, 0, "true");			deletion_result=File.delete(current_dir+currentFile);		}		collect_garbage(50);	}	return errorLog;}// function : measureSummation // inputs:// density -> density screened in (eg 384 or 1536)// rows, cols -> number of rows and columns that make up the ordered grid of colonies// grid_width, grid_height -> width and hieght of a cell within the grid of colonies// current_dir -> directory where current image resides// home_dir -> parent directory where this all started// save_dir -> where to move successfully processed images// error_dir -> where to move unsuccessfully processed images// currentFile -> file name of current image being processed // errorLog -> log used to keep track of any error message we encounter// returns:// errorLog// purpose:// measure area of colonies present on plate using summation mode. This mode applies a threshold filter to the image and analyzes// all the particles in the image. It the divides a image into a grid based on the number of rows and cols of colonies present (which was // previously determined, based on density ) and then assigns colony area values by taking the sum of all particles within each cell of the grid. function measureSummation(density, rows, cols, grid_width, grid_height, current_dir, home_dir, save_dir, error_dir, currentFile, errorLog){	analyzeParticles(0,0.00,"");	// following array will hold the x and y coordinates of the centroid of all colonies and their sizes	x_centroids=newArray(nResults);	y_centroids=newArray(nResults);	sizes=newArray(nResults);	stepper = setStepper(density,cols);	//if(showDebug){showMessageWithCancel((density-nResults)+"\n"+stepper);}	// get centroid coordinates and sizes	average=0;	maxSize=0;	modColonies=0;	circOfMax=0;	for (i=0; i<nResults; i++) {		x_centroids[i]=getResult("X",i);		y_centroids[i]=getResult("Y",i);		sizes[i]=getResult("Area", i);		if(sizes[i]>25){			average+=sizes[i];			modColonies++;		}		if(sizes[i]>maxSize){			maxSize=sizes[i];			circOfMax = getResult("Circ.", i);		}	}	goodPlate = "true";	if(maxSize > (grid_width * grid_height) && circOfMax > 0.009 ){		// Possible thresholding issue		goodPlate = checkThreshold(current_dir, error_dir, currentFile);		if(goodPlate != "true"){errorLog=errorLog+goodPlate;}	}	if(goodPlate == "true"){		average=average/modColonies;		modColonies1=0;		modCutOff=average*0.4; // 0.4 = arbitrary (sounds better if I say "empirically determined')		stdev=0;		for(i=0;i<sizes.length;i++){			if(sizes[i] > modCutOff){modColonies1++;}			if(sizes[i]>25){stdev+=pow((sizes[i]-average),2);} // 25 = arbitrary (sounds better if I say "empirically determined')				}		stdev=sqrt( (stdev/(modColonies-1) ) );		sizeCeiling=average+stdev;		sizeFloor=average-stdev;		// iterate over rows and columns, set x and y range where centroid should lie, iterate over x and y centroid arrays		// if centroid falls within range then add the corresponding colony size to the results array, if no centroid found		// to fall within range add 0 to results array.		// Once a size has been assigned to results array, increment assignments variable.  This will allow us to track how many 		// sizes were pushed into the results array.  If this number significantly differentiates from the length of the sizes array		// then we have an issue		startingK=0;		colonyNum=0;		myCounter=0;		size_results=newArray(density);		circ_results=newArray(density);		for(i=0;i<rows;i++){			for(j=0;j<cols;j++){				showProgress( (colonyNum/density) );				index=i+j*rows;				size_results[index]=0;				circ_results[index]=0;				xCenFloor=j*grid_width;				xCenCeiling=xCenFloor+grid_width;				yCenFloor=i*grid_height;				yCenCeiling=yCenFloor+grid_height;				nextYCeiling=yCenCeiling+grid_height;			//	if(showDebug){showMessageWithCancel("\nxCenFloor = "+xCenFloor+"\nxCenCeiling = "+xCenCeiling+"\nyCenFloor = "+yCenFloor+"\nyCenCeiling = "+yCenCeiling+"\nfloor = "+sizeFloor+"\nceiling = "+sizeCeiling);}				for(k=startingK; k < x_centroids.length; k++){					if(y_centroids[k] > nextYCeiling){k=x_centroids.length;}					else{						if(x_centroids[k] > xCenFloor && x_centroids[k] < xCenCeiling){ // check to see if centroid lies within x range							if(y_centroids[k] > yCenFloor && y_centroids[k] < yCenCeiling){ // check to see if centroid lies within y range								myCounter++;								size_results[index]=size_results[index]+sizes[k];							}						}					}				}				colonyNum++;			}			startingK=((i+1)*cols)-(stepper);			if(startingK<0){startingK=0;}		}	}	moveImage(current_dir, save_dir, currentFile, 0, 0, 0, 0, 0, "true");	selectWindow("Log");	print(currentFile);	printArray(size_results);	selectWindow("Log");	saveAs("txt", home_dir+logFileName);// save after each iteration in case program crashes	return errorLog;}// function : medianArrayValue// inputs:// array -> an array// returns:// median value of array// purpose:// calculates and returns the median value of an arrayfunction medianArrayValue(array){	if(array.length == 1){return array[0];}	temp = Array.copy(array);	Array.sort(temp);		if(temp.length % 2 != 0) {		return temp[round(temp.length/2+0.5)];	} 	else { // else number of indices is even		return (temp[temp.length/2] + temp[temp.length/2 - 1]) / 2;	}}// function : moveAllFiles// inputs:// fromDir -> directory containing files to move// toDir -> destination directory // purpose:// moveAllFiles moves all files from one directory (fromDir) to another (toDir). Does not return anythingfunction moveAllFiles(fromDir,toDir){	if(!File.isDirectory(toDir)){File.makeDirectory(toDir);} // if toDir does not exist, create it	filesToMove=getFileList(fromDir); // get files in toDir	for(ijk=0;ijk<filesToMove.length;ijk++){		open(fromDir+filesToMove[ijk]); // open file		selectWindow(filesToMove[ijk]); // select the proper window		save(toDir+filesToMove[ijk]);  // save file to new directory		close(); // close file		deletion_result=File.delete(fromDir+filesToMove[ijk]); // delete old copy	}}// function : moveImage// inputs:// current_dir -> directory in which current image resides// save_dir -> where you would like to save this image// fileName -> the file name of the image// l -> left (x) border of selection box if this image is to be cropped prior to saving// t -> top (y) border of selection box if this image is to be cropped prior to saving// w -> width of selection box if this image is to be cropped prior to saving, if this == 0 image will not be cropped// h -> height of selection box if this image is to be cropped prior to saving, if this == 0 image will not be cropped// angle -> angle, in degrees, to rotate this image prior to saving// close_first -> if this is == "true" image will be closed and re-opened prior to saving (useful, for example, if image // 								had had a threshold applied but you do not want to save the image with the threshold).// purpose:// Moves image from current_dir to save_dir. If the proper variables are present will also close and re-open, crop, and/or rotate// image prior to movingfunction moveImage(current_dir, save_dir, fileName, l, t, w, h, angle, close_first){	if(!File.isDirectory(save_dir)){File.makeDirectory(save_dir);}	if(close_first == "true"){		close_window(fileName);		open(current_dir+fileName);	}	// if this is a error directory, also attempt to save a copy of the original image in a sub dir of the error folder	if(indexOf(substring(save_dir, lengthOf(save_dir)-10), "error") > 0 && indexOf(save_dir, "rough_crop_error")<1){		error_dir=save_dir+"originals/";		if(!File.isDirectory(error_dir)){File.makeDirectory(error_dir);}		saveAs("Tiff", error_dir+fileName);	}	// rotate image if angle != 0	if(angle != 0){run("Rotate... ", "angle="+angle+" interpolation=Bilinear");}	// crop image if w AND h are != 0	if(w > 0 && h > 0){		makeRectangle(l,t,w,h);		if(showDebug){showMessageWithCancel("l = "+l+"\nt = "+t+"\nw = "+w+"\nh = "+h);}		run("Crop");	}	saveAs("Tiff", save_dir+fileName); // save image to new directory	deletion_result=File.delete(current_dir+fileName); // delete original	close();}// function : namePlate// inputs:// plateID -> plate number with condition appended// con_ids -> array containing all plate ids found// con_labels -> array containing user defined labels for the ids in con_ids// query -> query indicated in scan// returns:// a full name name comprised of the query, plate number (or id) and condition// purpose:// combines info in the variables passed to it to return a proper name for the plate (see return value). Used when rough cropping// images containing multiple plates into individual plate images (aka rough cropping)function namePlate(plateID,con_ids,con_labels,query){	// look up condition identifier in con_ids array, if found assign condition to the 	// corresponding element in the con_labels array	original_plate_name=plateID;	condition="";	found=false;	name_length=lengthOf(plateID);	last_index=name_length;	last_index--;	length_of_condition_symbol=0;	while(last_index > 0){		character=substring(plateID, last_index, (last_index+1));		last_index--;		// no  \ / : ? " < > | allowed in windows file names so we won't consider as condition		// identifiers.  Will use +, ~, ^, #, @		if(character=="+" || character=="~" || character=="^" || character=="#" || character=="@"){			condition=character+condition;			length_of_condition_symbol++;		}		// break out of loop		else{last_index=-1;}	}	if(condition != ""){ // if a condition for this plate was found then determine its appropriate label....		for(j=0;j<con_ids.length;j++){			if( condition==con_ids[j] ){				condition=con_labels[j]; // replace the condition id with the appropriate label				found=true;				plateID = substring(plateID,0,name_length-length_of_condition_symbol); // remove condition id from plateID				j=con_ids.length; // assign j=con_ids.length to get out of for loop			}		}	}	// if condition symbol not found, either there is no condition or the condition has not been identified	last_index=name_length;	last_index--;	character=substring(original_plate_name, last_index, (last_index+1));	if(found==false && (character=="+" || character=="~" || character=="^" || character=="#" || character=="@")){exit(character+"Had an issue finding the condition for the symbol at the end of '"+query+","+plateID+"'.  Exiting."); }	plateID=query+","+plateID+","+condition;	return plateID;}// function : onOpenMethods// inputs:// f -> full path of file to open// a -> angle to rotate image after opening it// density -> density of colonys on plate (eg 1536, 384)// cropArray -> array containing coordinates to crop image after opening it// threshold -> should images be subjected to a threshold filter// purpose:// close (if specified) and opens an image, crops the image if specified according to the dimensions // in the cropArray array. Removes any scale from image, sets the measurements, checks if image is a stack,// rotates image if specified, applies a threshold filter, checks to see if the image needs to be // inverted or notfunction onOpenMethods(f,a, noClose,density, cropArray, threshold){	if(noClose!="yes"){close();}	open(f);	if(noClose=="crop_me"){makeRectangle(cropArray[0],cropArray[1],cropArray[2],cropArray[3]);run("Crop");}	run("Set Scale...", "unit=");	run("Set Measurements...", "area mean min centroid bounding circularity redirect=None decimal=6");	checkIfStack(); // checks to see if image is a stack, if it is this function will flatten it	if(a!=0){run("Rotate... ", "angle="+a+" interpolation=Bilinear");}	if(threshold){		convertToBlackWhite(1); // threshold image		analyzeParticles(20,0.8,""); // measure all particles		checkParticles(density); // check to see if we need to invert image or not	}}// function : printArray// inputs:// a -> any array// purpose:// prints arrayfunction printArray(a) {for (i=0; i<a.length; i++){print(a[i]);}}// function printArray// inputs:// sizes -> any array// circs -> any array// printIndex -> boolean value....should the index number be printed as well?// purpose:// Assumes sizes and circs are same size. Iterates over arrays printing values from each array separated by tabs.function printResults(sizes,circs, printIndex) {	if(printIndex){		for (i=0; i<sizes.length; i++){print(i+") " + sizes[i]+"\t"+circs[i]);}	}	else{		for (i=0; i<sizes.length; i++){print(sizes[i]+"\t"+circs[i]);}	}}// function : processFileName// inputs:// s_name -> file name to process (i think i called this variable s_name for scan name)// returns:// fileName with file extension removed and rest of fileName will have its periods replaced with underscores// purpose:// processes image file namesfunction processFileName(s_name){	if(s_name.length>2){ // s_name contains > 1 period in fileName		temp='';		for(i=0;i<(s_name.length-1);i++){temp=temp+"_"+s_name[i];} // concatenate array		s_name=substring(temp,1); // strip out preceeding underscore character	}	else{s_name=s_name[0];} // else only period in fileName is for file extension	return s_name;}// function : processScans// inputs:// home_dir -> parent directory from which all the processing starts// files -> array of file names in the home_dir// condition_ids -> array of condition ids// condition_labels -> array of labels that correlate to the condition ids// purpose:// crops scans into individual images of plates. Relies on the fact that the background of the scan is black,// that there is a small amount of space between the plates, that the plates are distributed evenly // across the scan, and that the plates are positioned vertically with position A1 in the bottom rightfunction processScans(home_dir, files, condition_ids, condition_labels){	errorLog="";	// this next if statement will display a rough crop progress bar if there are any files in the 	// current directory. This may not be the BEST way to do this since these could be any type of file,	// not just image files	errorFolder=home_dir+"rough_crop_errors/";	if(files.length > 0){		createProgressBar("Rough Crop Progress");		if(showDebug){showMessageWithCancel("Begin rough-cropping multi-plate scans.");}	} 	i=0;	for (ii=0; ii<files.length; ii++){		// check to ensure file exists and that file is an image		if(!File.isDirectory(home_dir+files[ii])){			s_name=split(files[ii],".");			extension=s_name[(s_name.length-1)]; 			if(extension=="tiff" || extension=="tif" || extension=="gif" || extension=="jpeg" || extension=="bmp" || extension=="jpg" || extension=="png"){				// will store original scans, could do this above but do not want to create this unless there are images in this directory				if(!File.isDirectory(home_dir+"original_scans/")){File.makeDirectory(home_dir+"original_scans");}				// if out folder does not exist, create it				if(!File.isDirectory(home_dir+"rough_crops/")){File.makeDirectory(home_dir+"rough_crops");} // will store rough_cropped images				s_name=processFileName(s_name);	// remove periods in fileName as well as file extension				if(showDebug){showMessageWithCancel("file name = "+s_name);}				s_name=split(s_name, ","); // split processed file name by commas				// open image, save copy of original				open(home_dir+files[ii]);				run("Select All");				run("Duplicate...", "temp"); // creates a new copy of the image based on selection				//selectWindow("temp");				saveAs("Tiff", home_dir+"original_scans/"+files[ii]); // save copy				close(); // close copy				selectWindow(files[ii]); // select image				checkIfStack(); // checks to see if image is a stack, if it is this function will flatten it				run("8-bit"); // convert to grayscale				width = getWidth();				height = getHeight();				blackValue=getBlackValue(); // determine if black value is 0 or 255, it should be 0 but some people's configs may be messed up				r_and_c=determineRowsAndColsProfile(blackValue);				threshold = (r_and_c[3] - r_and_c[2]) / 2 + r_and_c[2];				trimBorder(width,height,blackValue, "white",10,70,0); // trim black from edge of image				trimBorder(width,height,blackValue, "black",10,threshold,0); // trim black from edge of image				if(showDebug){showMessageWithCancel("number of plates in image = "+(s_name.length-1));}				errorLog = errorLog + roughCropScans(s_name, home_dir, errorFolder, blackValue, threshold, errorLog, files[ii], condition_ids, condition_labels);				close();				deletion_result=File.delete(home_dir+files[ii]);				collect_garbage(50);			}			changeProgress("Rough Crop Progress",ii, files.length, 233, 150, 122); // Dark Salmon		}	}	close_window("Rough Crop Progress");	print("\\Clear"); // clear log file	if(errorLog != ""){ // print and save error log if it exists.		if(!File.isDirectory(errorFolder)){File.makeDirectory(errorFolder);} // will store error scans		print (errorLog);		selectWindow("Log");		saveAs("txt", errorFolder+"error_notes");		errorLog="";		close_window("Log");	}}// function roughCropScans// input:// s_name -> array of file name with file extension removed, split by commas// home_dir -> parent directory we are operating from// blackValue -> numeric value of black (0 or 255)// errorLog -> holder error messages// errorFolder -> where to put images if an error occurs// fileName -> name of file// condition_ids -> array containing condition ids present in file names// condition_labels -> user defined labels for the condition_ids// returns:// an updated (if required) errorLog// purpose:// Rough crops scans based on formating of fileName. The fileName should be formated in such a way to indicate the number of plates// present in the scan. If the number of plates indicated in the file name exceeds the capacity of the image (based on the value// returned by the determineRowsAndCols function) then the image is placed in the errorFolder. Otherwise it is porcessed normally.// Normal processing includes: determining the number of rows and columns of plates present in the scan (assumes black border surrounding// plates, that plates are verticle with position A1 in the lower left corner, and that the plates are distributed symetrically [aka in a grid])// plates are then cropped, rotated, and have any black border surrounding them removed. They are then moved into the "rough_crops" directoryfunction roughCropScans(s_name, home_dir, errorFolder, blackValue, threshold, errorLog, fileName, condition_ids, condition_labels){	// singlePlateHighWidth, singlePlateLowWidth, singlePlateHighHeight, singlePlateLowHeight, lowWidth, and highWidth =	// globally defined variables that you can find at the top of this macro	scanName=getTitle(); // image name	width = getWidth();	height = getHeight();	getPixelSize(unit, pw, ph, pd);	widthInches=width*pw;	heightInches=height*ph;	numplates = newArray(s_name.length-1); // number of plates expected in scan	for (iii=0; iii<numplates.length; iii++){numplates[iii] = iii+1;} // numplates now == series starting a 1	if(showDebug){showMessageWithCancel("title","name = "+scanName+"\nsize = "+numplates.length+"\nw="+widthInches+"\nh="+heightInches+"\nunit = "+unit);}	// maybe it's 1 plate (oriented vertically)...	if(widthInches < singlePlateHighWidth && widthInches > singlePlateLowWidth && heightInches < singlePlateHighHeight && heightInches > singlePlateLowHeight){		name=namePlate(s_name[1],condition_ids,condition_labels,s_name[0]);		run("Rotate 90 Degrees Right"); // assumes position A1 is in bottom right of image		saveAs("Tiff", home_dir+"rough_crops/"+name);		return '';	}	// 2-9 plates?	if((widthInches > lowWidth && widthInches < highWidth) || unit != "inches"){		x=0;		y=0;		row=0;		//r_and_c=determineRowsAndCols(height,width,blackValue);		r_and_c=determineRowsAndColsProfile(blackValue);		run("Set Scale...", "unit=");		imageWidth=width/r_and_c[1];		imageHeight=height/r_and_c[0];		capacity=r_and_c[0]*r_and_c[1];				largerDimension = r_and_c[0];		if(r_and_c[1] > largerDimension){largerDimension = r_and_c[1];}		row_position_array=newArray(capacity);		c=0; last=0;		for(i=1;i<=r_and_c[0];i++){ // rows			for(j=1;j<=r_and_c[1];j++){ // cols					row_position_array[c++]=i;			} 		}		if(showDebug){showMessageWithCancel("capacity = "+capacity+"\nsize = "+numplates.length);}		if( numplates.length < 1){			moveImage(home_dir, errorFolder, fileName, 0, 0, 0, 0,0, "false"); // move image to error directory			errorLog = errorLog+"\nOriginal Scan: "+fileName+" was unable to be rough cropped.\nYour filename did not include a plate number, which CM Engine requires. Plate numbers may be included in filenames after the query. For example: filename 'control,1.jpg'  contains a single plate (plate 1) and the query is 'control'.\n";		}		else if( numplates.length < (capacity-largerDimension+1) ){			if(!File.isDirectory(errorFolder)){File.makeDirectory(errorFolder);} // will store error scans			saveAs("Tiff", errorFolder+fileName);			errorLog=errorLog+"\nOriginal Scan: "+fileName+" was unable to be rough cropped.\nPlease ensure the area surrounding all plates in your scans is black.\nAlso make sure that your images are named appropriately. This program thinks there  ";			if((capacity-largerDimension+1) < capacity){				errorLog=errorLog+"are "+(capacity-largerDimension+1)+" to "+capacity+" plates"; 			}			else{				errorLog=errorLog+"is "+capacity+" plate"; 			}			 errorLog=errorLog+" in this image, but according to the way you named this plate there should be at least "+(numplates.length)+".";		}		else if( numplates.length > capacity){			if(!File.isDirectory(errorFolder)){File.makeDirectory(errorFolder);} // will store error scans			saveAs("Tiff", errorFolder+fileName);			errorLog=errorLog+"\nOriginal Scan: "+fileName+" was unable to be rough cropped.\nPlease ensure the area surrounding all plates in your scans is black.\nAlso make sure that your images are named appropriately. This program thinks there ";			if((capacity-largerDimension+1) < capacity){				errorLog=errorLog+"are "+(capacity-largerDimension+1)+" to "+capacity+" plates"; 			}			else{				errorLog=errorLog+"is "+capacity+" plate"; 			}			 errorLog=errorLog+"in this image, but according to the way you named this plate there are "+(numplates.length)+" plates.";		}		else{			for (i=0; i<numplates.length; i++){				row=row_position_array[i];				x=(i%r_and_c[1])*(width/r_and_c[1]);				y=(row-1)*(height/r_and_c[0]);				plateID = s_name[numplates[i]];				plateID=replace(plateID, "^ *", ""); // replace space characters at begining of plate identifier				plateID=replace(plateID, " *$", ""); // replace space characters at end of plate identifier				name=namePlate(plateID,condition_ids,condition_labels,s_name[0]); // note s_name[0] == query identifier of this image				if(showDebug){showMessageWithCancel("selection --> "+selectionType());}								makeRectangle(x, y, imageWidth, imageHeight);				run("Duplicate...", name); // creates a new copy of the image based on selection				run("Rotate 90 Degrees Right"); // rotate image				run("8-bit"); // convert to grayscale				new_height=getHeight();				new_width=getWidth();				trimmedDimensions = trimBorder(new_width,new_height,blackValue,"black",10,threshold,0); // trim black from image borders				if(trimmedDimensions[0] < 0 && trimmedDimensions[1] < 0 && trimmedDimensions[2] < 0 && trimmedDimensions[3] < 0){					 i=numplates.length;					// if out folder does not exist, create it					if(!File.isDirectory(errorFolder)){File.makeDirectory(errorFolder);}// will store error scans					saveAs("Tiff", errorFolder+fileName);					errorLog=errorLog+"\nOriginal Scan: "+fileName+" was not rough cropped.\nSomething is wrong with the way it was scanned.\nPlease ensure you scanned it properly.\nImages should be scaled 100% and should have:\nA minimal width of "+singlePlateLowWidth+"\nA maximum width of "+singlePlateHighWidth+"\nA minimal height of "+singlePlateLowHeight+"\nA maximum height of "+singlePlateHighHeight+"\nIf your plates do not fit within these constraints you may alter them by editing the variables at the top of this macro (singlePlateLowWidth, singlePlateHighWidth, singlePlateLowHeight, singlePlateHighHeight.";					close();					selectWindow(scanName);				}				else{					if(showDebug){showMessageWithCancel("name = "+name);}					saveAs("Tiff", home_dir+"rough_crops/"+name);					close();					selectWindow(scanName);				}				run("Clear Results");				selectWindow(scanName);			}		}		//if(showDebug){showMessageWithCancel(errorLog);}	}	else{		// if out folder does not exist, create it		if(!File.isDirectory(errorFolder)){File.makeDirectory(errorFolder);}// will store error scans		saveAs("Tiff", errorFolder+fileName);		errorLog=errorLog+"\nOriginal Scan: "+fileName+" was not rough cropped.\nSomething is wrong with the way it was scanned.\nPlease ensure you scanned it properly.\nImages should be scaled 100% and should have:\nA minimal width of "+singlePlateLowWidth+"\nA maximum width of "+singlePlateHighWidth+"\nA minimal height of "+singlePlateLowHeight+"\nA maximum height of "+singlePlateHighHeight+"\nIf your plates do not fit within these constraints you may alter them by editing the variables at the top of this macro (singlePlateLowWidth, singlePlateHighWidth, singlePlateLowHeight, singlePlateHighHeight.";					}	if(showDebug){showMessageWithCancel(errorLog);}	return errorLog;}// density -> colony density of plate (eg 384 or 1536)// cols -> number of columns// returns:// appropriate stepper value// purpose:// sets the value of stepper, a variable used when measuring colony areas. This variable allows for// more efficient assignment of particles to cells...(that all makes sense right?????)function setStepper(den,cols){// pdifferenes is no longer used, but if uncommented it would allow you to keep track of the// difference between the number of particles on a plate and the density the user entered	if(den>384){		if( (den-nResults) < 50 ){stepper=cols;}		else if( (den-nResults) < 100 ){		//	pdifferences=pdifferences+fileName+" - "+(den-nResults)+"\n";			stepper=cols*4;		}		else if( (den-nResults) < 150 ){		//	pdifferences=pdifferences+fileName+" - "+(den-nResults)+"\n";			stepper=cols*6;		}		else{stepper=cols*8;}	}	else{		if( (den-nResults) < 25 ){stepper=cols;}		else if( (den-nResults) < 50 ){		//	pdifferences=pdifferences+fileName+" - "+(den-nResults)+"\n";			stepper=cols*4;		}		else if( (den-nResults) < 75 ){		//	pdifferences=pdifferences+fileName+" - "+(den-nResults)+"\n";			stepper=cols*6;		}		else{stepper=cols*8;}	}	return stepper;}// function : showErrors// inputs:// errors -> an array that contains the indices of the particles that are suspect// yCens -> an array containing the y centroid corrdinate of all particles on the plate// xCens -> an array containing the x centroid corrdinate of all particles on the plate// cir -> an array containing the circularity measurements of all particles on the plate// size -> an array containing the area measurements of all particles on the plate// count -> the number of abnormalities detected// purpose:// showErrors preseents a dialog to users that informs them of any dectected abnormalities on // plates and allows the user to use ImageJ's built in editting commands to correct themfunction showErrors(errors, yCens, xCens, cir, size, count){	report="";	end=minOf(count,15); // show maximum of 15 errors	for(iii=0;iii<end;iii++){report=report+""+(iii+1)+") X position = "+round(xCens[errors[iii]])+", Y position = "+round(yCens[errors[iii]])+", Circularity = "+ d2s(cir[errors[iii]], 2) + ", Size = "+size[errors[iii]]+"\n";}	//setColor(255);	//setForegroundColor(255, 255, 255);	//setTool(18); // eraser tool	if(count>end){report="THERE ARE MORE THE 15 BLEMISHES ON THIS PLATE!\nONLY DISPLAYING INFORMATION ABOUT THE FIRST 15.\n"+report;}	waitForUser("Blemish Notification - Action Required", "Looks like there are some blemishes on your plate.  The locations of particles considered blemishes are shown below and when your mouse cursor is hovering over your image and the\nImageJ window is active, ImageJ will report your current cursor position in its status window.\nPlease fix your plate now using the brush tool (if you are erasing artifacts set the color of the brush to be the same as the background of the image) and then press OKAY to continue.\nIf you plate appears normal you may ignore this message and press OKAY to continue.\n"+" \n "+report);}// function : thresholdImage// purpose:// applies threshold filter to imagefunction thresholdImage(){	run("Threshold", "thresholded remaining black");	run("Convert to Mask", "calculate black");}// function : trimArray// input:// array to be trimmed// purpose:// iterates over array, as soon as it encounters a negative value it removed that value and all subsequent values from the array// example:// if your array contains the following values: [1, 34, 34, 23, -1, -1, -1, 24]// this function will return the following array: [1, 34, 34, 23]// returns:// trimmed arrayfunction trimArray(array){	for(i=0;i<array.length;i++){		if(array[i]<0){return Array.trim(array,i);}	}	return array;}// function : trimBorder// inputs:// width, height -> integers, width and height of image// blackValue -> integer, value of black (0 or 255)// colorToTrim -> string, what color you want to trim from image border (should be "black" OR "white")// stepValue -> integer, while looking for edge, how far to step each iteration (see findEdge function for clarification) // thresholdValue -> integer, when triming the edges, how much of a difference between the interior and exterior of the edge//									 should there be (lower == more sensitive)// amount of padding to use around image// purpose:// crops away black surrounding image (subject to threshold value of findEdge function)// returns: // array containing dimensions of new crop...function trimBorder(width,height,blackValue, colorToTrim, stepValue, thresholdValue, padding){	// trim black from scan borders, after which the plates should be distributed evenly across the image	left=findEdge(0,0,0,height,stepValue,"true",colorToTrim,blackValue, width, thresholdValue);	//if(showDebug){showMessageWithCancel("now top");}	top=findEdge(0,width,0,0,stepValue,"false",colorToTrim,blackValue, height,thresholdValue);	//if(showDebug){showMessageWithCancel("now right");}	stepValue*=-1; // reverse sign of stepValue	right=findEdge(width,width,0,height,stepValue,"true",colorToTrim,blackValue, width,thresholdValue);	//if(showDebug){showMessageWithCancel("now bottom");}	bottom=findEdge(0,width,height,height,stepValue,"false",colorToTrim,blackValue, height,thresholdValue);	left=left-padding;	top=top-padding;	width=right-left+(padding*2);	height=bottom-top+(padding*2);	makeRectangle(left, top, width, height);	if(showDebug){showMessageWithCancel("selection --> "+selectionType());}	if(selectionType() <0){ return newArray(-1, -1, -1, -1);}	run("Crop");	return newArray(left, top, width, height);}function userSelectionAlignAndCrop(imageName,cropImage){	run("Clear Results"); // uuummm this clears the results dialog	setTool("multipoint");	selectWindow(imageName); // select window	width = getWidth();	height = getHeight();	run("Select None");		setTool("multipoint");	// makePoint(200, 66);	// run("Measure");	// makePoint(1584, 62);	// run("Measure");	// makePoint(1576, 1460);	// run("Measure");	waitForUser("Please select corner colonies", "Action Required!\nIf image is rotated more than 90 degrees from proper orientation, please rotate it appropriately prior to selecting corners.\nPlease select exactly 3 corner positions (e.g. for starndard 96-density format A1, A12, and H1).\nIf you make an error you may clear your selections by  selecting from the Edit Menu: 'Edit->Selection->Select None'.\n\nAfter you have selected 3 corners, click the 'OK' button to continue.");	run("Measure");	while(nResults != 3){		run("Clear Results"); // clear the results dialog		selectWindow(imageName); // select window		waitForUser("Error, "+nResults+" selections found, exactly 3 are required.", "If image is rotated more than 90 degrees from proper orientation, please rotate it appropriately prior to selecting corners.\nPlease select exactly 3 corner positions (e.g. for starndard 96-density format A1, A12, and H1).\nIf you make an error you may clear your selections by  selecting from the Edit Menu: 'Edit->Selection->Select None'.\n\nAfter you have selected 3 corners, click the 'OK' button to continue.");		run("Measure");	}	validPoints = 0;	tolerance=0.05; // set difference allowable between corner points	x_array=newArray(3); // will store x coordinates	y_array=newArray(3); // will store y coordinates	minY=width*height;	for (i=0; i<3; i++) {		x_array[i] = getResult("X",i);		y_array[i] = getResult("Y",i);	}	// find corners of plates by determining maximum euclidean distance	eMax=0;	eMaxIndex1=0;	eMaxIndex2=0;	for (i=0; i<3; i++) {		for (j=0; j<3; j++) {			eDist=eDistance(x_array[i],y_array[i],x_array[j],y_array[j]);			if(eDist>eMax){				eMax = eDist;				eMaxIndex1=i;				eMaxIndex2=j;			}		}	}	// should now have 2 corners, the other 'odd man out' index should line up with both of the other points, use this info to rotate the image into alignment	oddMan = 0;	for (i=0; i<3; i++) {	if(i != eMaxIndex1 && i != eMaxIndex2){oddMan=i;i=50;}	}		x_diff=x_array[eMaxIndex1]-x_array[oddMan]; 	y_diff=y_array[eMaxIndex1]-y_array[oddMan]; 	angle=atan( (y_diff/x_diff) )*(180/PI);	initialAngle=angle;	if(abs(angle) != 0 && abs(angle)!=0){		opposite = 0;		// vertical triangle		if(abs(y_diff) > abs(x_diff)){			if(x_diff > 0){angle = abs(angle)-90;}			else{angle=90-abs(angle);}			opposite = x_diff;		}		// horizontal triangle always needs to reverse the angle		else{angle = angle*-1; opposite = y_diff;}		if(showDebug){showMessageWithCancel("initialAngle = "+initialAngle+"\nangle = "+angle+"\npoints = "+eMaxIndex1+" and "+oddMan+"\n ydiff = "+y_diff+"\n xdiff = "+x_diff);}		run("Rotate... ", "angle="+angle+" interpolation=Bilinear");	}	else{angle=0;}	// now need to figure out how much to adjust the rectangle bounds to match up with the rotation	xCenter = width/2;	yCenter = height/2;	xyAdjustment = adjustPointsAfterRotation(x_array[eMaxIndex1],y_array[eMaxIndex1],xCenter,yCenter, angle);	x_array[eMaxIndex1]=xyAdjustment[0];	y_array[eMaxIndex1]=xyAdjustment[1];	quadrant1 = xyAdjustment[2];	xyAdjustment = adjustPointsAfterRotation(x_array[eMaxIndex2],y_array[eMaxIndex2],xCenter,yCenter,angle);	x_array[eMaxIndex2]=xyAdjustment[0];	y_array[eMaxIndex2]=xyAdjustment[1];	quadrant2 = xyAdjustment[2];	setKeyDown("none");	selectionWidth = abs(x_array[eMaxIndex1]-x_array[eMaxIndex2]);	selectionHeight = abs(y_array[eMaxIndex1]-y_array[eMaxIndex2]);	padding=10;	selectionWidth+=padding;	selectionHeight+=padding;	padding = padding/2;	x=0;y=0;	if(quadrant1 == 1){		x=x_array[eMaxIndex1]-padding;		y=y_array[eMaxIndex1]-padding;	}	else if(quadrant1 == 2){		x=x_array[eMaxIndex1]-selectionWidth+padding;		y=y_array[eMaxIndex1]-padding;	}	else if(quadrant1 == 3){		x=x_array[eMaxIndex1]-padding;		y=y_array[eMaxIndex1]-selectionHeight+padding;	}	else if(quadrant1 == 4){		x=x_array[eMaxIndex1]-selectionWidth+padding;		y=y_array[eMaxIndex1]-selectionHeight+padding;	}	//makeRectangle(x, y, selectionWidth, selectionHeight);	// refine left border	//showMessageWithCancel("old");	newLeftX=x; //+refineBorder(x, x, y, y+selectionHeight, -1, false);	newRightX=x+selectionWidth; //+refineBorder(x+selectionWidth, x+selectionWidth, y, y+selectionHeight, 1, false);	newTopY=y;//+refineBorder(x, x+selectionWidth, y, y, -1, true);	newBottomY=y+selectionHeight; //+refineBorder(x, x+selectionWidth, y+selectionHeight, y+selectionHeight, 1,true);	run("Select None");		//setTool("rectangle");	//showMessageWithCancel(newLeftX+"\n"+newTopY+"\n"+(newRightX-newLeftX)+"\n"+(newBottomY-newTopY));		makeRectangle(newLeftX, newTopY, (newRightX-newLeftX), (newBottomY-newTopY));	//showMessageWithCancel("new");		waitForUser("Verify Crop Selection", "Please verify the dimensions of the selection box. If it is off adjust it appropriately. When you are done, click 'OK'.");	if(cropImage){run("Crop");}	return angle;	//showMessageWithCancel("cropped");}function adjustPointsAfterRotation(x, y, xCenter, yCenter, angle){	hypot = eDistance(x,y,xCenter,yCenter);	side1 = sin(angle*PI/180) * hypot;	xAndYadjustment = sin(45*PI/180) * side1;	//showMessageWithCancel(xAndYadjustment);		quad = 0;	if(x < xCenter){		// we are in the left half		if(y < yCenter){			// we are in top left quadrant			x = x+xAndYadjustment;			y = y-xAndYadjustment;			quad=1;		}		else{			// we are in bottom left quadrant			x = x-xAndYadjustment;			y = y-xAndYadjustment;			quad=3;		}	}	else{		// we are in the right half		if(y < yCenter){			// we are in top right quadrant			x = x+xAndYadjustment;			y = y+xAndYadjustment;			quad=2;		}		else{			// we are in bottom right quadrant			x = x-xAndYadjustment;			y = y+xAndYadjustment;			quad=4;		}	}	results=newArray(3);	results[0]=x;	results[1]=y;	results[2]=quad;	return results;}function refineBorder(x1,x2,y1,y2,direction,isTopBottom){	run("Clear Results"); // clear the results dialog	maxMoves=10;	minValue = 255;	consecutiveMeanDifference=0.5;	moveNumber=0;	makeLine(x1, y1, x2, y2);	run("Measure");	baseMean = getResult("Mean");	lastMean = baseMean;	while(moveNumber<maxMoves){		if(isTopBottom){makeLine(x1, y1+direction, x2, y2+direction);}		else{makeLine(x1+direction, y1, x2+direction, y2);}		run("Measure");		mean = getResult("Mean");		if((baseMean-mean) < consecutiveMeanDifference){moveNumber=maxMoves;}		else{			moveNumber+=1;			direction+=direction;		}	}	//showMessageWithCancel(direction);	return direction;}}